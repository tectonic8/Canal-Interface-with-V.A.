<!doctype html>
<html>
  <head>
    <title>Objective One</title>
    <style>
		#bigWrapper {position:fixed; right: 10; bottom: 10; width:700px; height:700px; margin: 0 auto; overflow:hidden; z-index:2}
		#clockDiv {position:relative; width:50px; height:50px; margin: 0 auto; overflow:hidden; font-size: 20px; z-index:99}
		#scoreDiv {position:relative; width:200px; height:50px; margin: 0 auto; overflow:hidden; font-size: 20px; z-index:100}
		#boatSprite1 {position:absolute; width:50px; height:35px; transition:none; transform-origin: 25px 17.5px; z-index: 95}
		#boatSprite2 {position:absolute; top:550px; left: 20px; width:50px; height:35px; transition: none; z-index: 93}
		#gowanusMap {position:relative; right: 10px; bottom: 10px; width:700px; height:700px; z-index: 4}
		#canvas {width:5100px; height:6600px; transition: none; z-index:1}
		#minimap {width:200px, height:228px; position:absolute; left:500px; top: 500px; border:1px solid #000000; z-index:79}
		#miniSprite1 {position:absolute; left:500px; top:690px; width:20px; height:20px; z-index:86}
		#miniSprite2 {position:absolute; left:500px; top:690px; width:20px; height:20px; z-index:85}
		.target {position: absolute; z-index:83}
	</style>
  </head>
  <body>
	<div id="bigWrapper">
		<canvas id="minimap" width="200" height="228"></canvas>
		<canvas id="canvas" width="5100" height="6600"></canvas>
		<img id="gowanusMap" src="canal3.png" alt="canalMap">
		<img id="boatSprite1" draggable="true" src="boatSprite1.png" alt="boatIcon">
		<img id="boatSprite2" draggable="true" src="boatSprite2.png" alt="boatIcon2">
		<img id="miniSprite1" src="miniSprite1.png">
		<img id="miniSprite2" src="miniSprite2.png">
	</div>
	<div id="clockDiv"></div>
	<div id="scoreDiv"></div>
    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script>
		(function(window, document) {
		var socket = io();
		socket.on('connect', function() {
			socket.emit("users", function(data) {
				clientContainer[0] = data[0];
				clientContainer[1] = data[1];
			});
		});
		var clientContainer = [];
		var ELEMENT_IDS = {
			canvas: "canvas",
			minimap: "minimap",
			userSprite: "boatSprite1",
			buddySprite: "boatSprite2",
			gowanusMap: "gowanusMap",
			miniSprite1: "miniSprite1",
			miniSprite2: "miniSprite2",
			divWrapper: "bigWrapper",
			clock: "clockDiv",
			scoreDiv: "scoreDiv"
		};
		var EVENTS = {
			LOAD:      'load',
			MOUSEDOWN: 'mousedown',
			MOUSEMOVE: 'mousemove',
			MOUSEUP:   'mouseup'
		};
		var canvas = document.getElementById(ELEMENT_IDS.canvas);
		var minimap = document.getElementById(ELEMENT_IDS.minimap);
		var gowanusMap = document.getElementById(ELEMENT_IDS.gowanusMap);
		var divWrapper = document.getElementById(ELEMENT_IDS.divWrapper);
		var clock = document.getElementById(ELEMENT_IDS.clock);
		var scoreDiv = document.getElementById(ELEMENT_IDS.scoreDiv);
		var ctx = canvas.getContext("2d");
		var minimapContext = minimap.getContext("2d");
		var canvasTopMargin = -4400;
		var canvasLeftMargin = 0;
		gowanusMap.addEventListener(EVENTS.LOAD, function(event) {
			ctx.drawImage(this, 0, 0); 
			canvas.style.marginTop = canvasTopMargin + "px";
			minimapContext.drawImage(this, 0, 480, 4066, 5000, 0, 0, 200, 228);
		});
		//not sure why it doesn't work without this part:
		document.addEventListener("DOMContentLoaded", function(event) {
			ctx.drawImage(gowanusMap, 0, 0);
			minimapContext.drawImage(canvas, 0, 480, 4066, 5000, 0, 0, 200, 228);
		});
		var userSprite = document.getElementById(ELEMENT_IDS.userSprite);
		var buddySprite = document.getElementById(ELEMENT_IDS.buddySprite);
		var miniSprite1 = document.getElementById(ELEMENT_IDS.miniSprite1);
		var miniSprite2 = document.getElementById(ELEMENT_IDS.miniSprite2);
		var canalTriacontapentagon = [[0, 2318], [84, 2318], [430, 1755], [552, 1617], [656, 1533], [812, 1499], [1055, 1531], [1292, 1583], [1495, 1265], [1510, 1067], [1899, 327], [1972, 365], [1584, 1101], [1580, 1286], [1623, 1319], [1527, 1474], [1483, 1445], [1344, 1663], [1370, 1754], [1611, 1909], [1566, 1975], [1311, 1817], [1279, 1683], [906, 1583], [766, 1579], [1098, 1797], [1050, 1863], [675, 1626], [569, 1721], [809, 1878], [770, 1948], [525, 1793], [75, 2480], [144, 2626], [0, 2655]];
		var vaCanalTriacontapentagon = [[0, 2318], [84, 2318], [430, 1755], [552, 1617], [656, 1533], [812, 1499], [1055, 1531], [1292, 1583], [1495, 1265], [1510, 1067], [1899, 327], [1972, 365], [1584, 1101], [1580, 1286], [1623, 1319], [1527, 1474], [1483, 1445], [1344, 1663], [1279, 1683], [906, 1583], [766, 1579], [675, 1626], [569, 1721], [525, 1793], [75, 2480], [144, 2626], [0, 2655]];
		for (var i = 0; i<= 34; i++) {
			canalTriacontapentagon[i][0] *= 2;
			canalTriacontapentagon[i][1] *= 2;
		}		
		for (var i = 0; i<= 26; i++) {
			vaCanalTriacontapentagon[i][0] *= 2;
			vaCanalTriacontapentagon[i][1] *= 2;
		}
		var miniSprite1coords = [500, 690];
		var miniSprite2coords = [500, 690];
		var rotate = 0;
		var log = '';
		var vaLog = '';
		
		var targetsCoords = [[227, 4694], [557, 4133], [1045, 3506], [1377, 3121], [2149, 3169], [2605, 3327], [2965, 2694], [3107, 2358], [3333, 1724], [3711, 960], [401, 4409], [708, 3924], [1158, 3256], [1828, 3079], [2786, 3014], [3206, 1962], [3471, 1451], [3600, 1214], [2428, 3215], [863, 3688]];
		var vaAim         = [[197, 4724], [527, 4163], [1015, 3536], [1347, 3151], [2119, 3159], [2580, 3305], [2935, 2624], [3077, 2388], [3303, 1754], [3781, 990]];
		var tagTargets = [];
		var userVerifyTargets = [];
		var vaVerifyTargets = [];
		var targetSprites = [];
		for (var i = 0; i<= 19; i++) { //this is necessary because the targets are appended to the wrapper, not the document body, now
			targetsCoords[i][0] -= 9;
			targetsCoords[i][1] -= 9;
		}
		var targetTracker = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; //0 means untagged, 1 means user verifies, 2 means va verifies, 3 means nonexistant
		
		//var accelerationData = [[0.487, 0.804, 0.844, 0.990, 0.992, 0.993, 1], [0.325, 0.354, 0.383, 0.450, 0.595, 0.612, 0.646, 1], [0.204, 0.212, 0.271, 0.376, 0.427, 0.442, 0.482, 0.498, 0.540, 0.615, 0.738, 0.861, 0.874, 1], [0.538, 1], [0.548, 1], [0.661, 0.987, 0.990, 0.991, 0.999, 1], [0.564, 1], [0.404, 0.533, 0.652, 1], [0.365, 0.470, 0.611, 0.642, 0.705, 1], [0.651, 0.945, 0.991, 1], [0.084, 0.093, 0.103, 0.108, 0.113, 0.123, 0.128, 0.137, 0.142, 0.155, 0.159, 0.164, 0.230, 0.245, 0.252, 0.266, 0.280, 0.294, 0.301, 0.315, 0.329, 0.343, 0.350, 0.364, 0.371, 0.385, 0.391, 0.416, 0.423, 0.429, 0.479, 0.494, 0.536, 0.545, 0.562, 0.587, 0.595, 0.603, 0.620, 0.643, 0.651, 0.672, 0.680, 0.687, 0.727, 0.751, 0.758, 0.774, 0.781, 0.796, 0.837, 0.910, 0.917, 0.958, 0.968, 1], [0.577, 1], [0.474, 0.719, 0.749, 0.804, 0.860, 1], [0.467, 0.585, 0.623, 0.851, 0.897, 1], [0.633, 0.760, 0.777, 1], [0.385, 0.452, 0.498, 0.521, 0.743, 0.778, 0.796, 0.813, 0.830, 1], [0.089, 0.108, 0.122, 0.140, 0.147, 0.158, 0.218, 0.234, 0.289, 0.317, 0.326, 0.353, 0.362, 0.380, 0.397, 0.438, 0.482, 0.508, 0.536, 0.571, 0.588, 0.605, 0.622, 0.630, 0.767, 0.868, 0.887, 1], [0.174, 0.211, 0.319, 0.352, 0.405, 0.468, 0.484, 0.529, 0.543, 0.571, 0.663, 0.751, 0.779, 0.818, 0.844, 0.953, 0.956, 0.960, 0.974, 0.983, 0.988, 1], [0.456, 0.630, 0.663, 0.694, 0.760, 0.819, 0.850, 0.983, 1], [0.389, 0.549, 0.583, 0.626, 0.648, 0.725, 0.764, 0.811, 0.830, 0.864, 0.882, 1], [0.569, 1], [0.259, 0.261, 0.670, 1], [0.548, 1], [0.482, 0.736, 0.758, 0.779, 0.813, 1], [0.456, 0.538, 0.644, 1], [0.392, 0.413, 0.415, 0.417, 0.631, 0.636, 0.833, 1], [0.562, 1], [0.513, 0.664, 0.692, 0.841, 0.899, 1], [0.813, 1], [0.634, 0.838, 0.868, 1], [0.427, 0.504, 0.635, 1], [0.761, 0.970, 0.981, 0.988, 0.996, 1], [0.603, 1], [0.745, 1], [0.729, 1], [0.569, 0.874, 0.931, 1], [0.534, 0.720, 0.772, 1], [0.426, 0.502, 0.727, 0.729, 0.730, 0.733, 0.890, 0.961, 0.987, 1], [0.342, 0.437, 0.520, 0.704, 0.823, 1], [0.575, 1], [0.562, 1], [0.292, 0.384, 0.385, 0.388, 0.676, 0.677, 0.909, 0.975, 0.976, 0.979, 0.994, 1], [0.247, 0.277, 0.559, 0.638, 0.746, 1], [0.556, 1], [0.386, 0.650, 0.900, 0.955, 0.956, 0.959, 0.985, 1], [0.557, 1],[0.473, 0.831, 0.887, 1]];
		//var accelerationData = [[0.129, 0.155, 0.168, 0.182, 0.195, 0.209, 0.223, 0.238, 0.252, 0.266, 0.281, 0.295, 0.324, 0.351, 0.364, 0.389, 0.893, 0.972, 0.996, 1], [0.513, 0.664, 0.692, 0.841, 0.899, 1], [0.493, 0.471, 0.731, 0.733, 0.734, 0.738, 0.92, 0.955, 0.984, 1], [0.72, 1]];
		var accelerationData = [[0.129, 0.155, 0.168, 0.182, 0.195, 0.209, 0.223, 0.238, 0.252, 0.266, 0.281, 0.295, 0.324, 0.351, 0.364, 0.389, 0.893, 1], [0.513, 0.664, 0.692, 0.841, 0.899, 1], [0.493, 0.471, 0.731, 0.733, 0.734, 0.738, 0.92, 1], [0.72, 1]]; //I haven't implemented making a decreasing progress work.
		var accelerationProportion = [0.768, 0.599, 0.644, 0.72];
		var preferenceData = [0.69, 0.86, 0.82, 0.00, 0.00, 0.27, 0.43, 0.75, 0.91, 0.87, 0.90, 0.47, 0.44, 0.40, 1]; //1 in the last index was made by me, it will not be randomly selected, only used when I want it to 100% verify
		var startDelayData = [500, 3599, 500, 1200, 801, 499, 890, 700, 900, 2700, 2401, 2598, 800, 800, 2701, 1000, 301, 3700, 4100, 4401, 6300, 4101, 4801, 4500, 2101, 6099, 5299, 5100, 3900, 3100, 6300, 4799, 3801, 4800, 4601, 3703, 5000, 9501, 3903, 5899, 4300, 4700];
		var tagTimeData = [26.7, 12.7, 10.4, 27.4, 7.7];
		//var tagTimeData = [6.7, 8, 7, 9, 10];
		var verifyTimeData = [6.2, 2.8, 3.2, 8.8, 3.9];
		
		var imageId = 1;
		var lastRole = "null";
		var accelerate2 = [0.7, 1];
		var elapsedTime = 0;
		var timeSpentTaggingVerifying;
		var lastTargetIndex = 20;
		var targetsVerified = 0;

		
		/*
		*/
	
		class Target {
			constructor(x, y, id, index, type) {
				var target = document.getElementById(id + index);
				target.setAttribute("width", 50);
				target.setAttribute("height", 50);
				target.setAttribute("class", "target");
				target.xPos = x - 14;
				target.yPos = y - 4412;
				target.style.left = target.xPos + "px";
				target.style.top = target.yPos + "px";
				
				var targetSprite = document.getElementById("miniTarget" + index);
				targetSprite.setAttribute("width", 15);
				targetSprite.setAttribute("height", 15);
				targetSprite.setAttribute("class", "target");
				targetSprite.style.left = (x-107)*0.048 + 501 + "px";
				targetSprite.style.top = (y-4864)*0.046 + 691 + "px";
				if (type == 0) {
					target.setAttribute("src", "target.png");
					targetSprite.setAttribute("src", "miniTarget.png");
				}
				if (type == 1) {
					target.setAttribute("src", "target2.png");
					targetSprite.setAttribute("src", "target2.png");
				}
				if (type == 2) {
					target.setAttribute("src", "target3.png");
					targetSprite.setAttribute("src", "target3.png");
				}
			}
		}

		class VirtualAgent {
			constructor(x, y, behavior) {
				this.behavior = behavior;
				this.sprite = document.getElementById(ELEMENT_IDS.buddySprite);
				this.position = {x:x, y:y};
				this.fastForward = false;
			}
			
			initialize(addDelay) {
				this.magnitude = 0;
				this.onTarget = false;
				this.counter = 0;
				this.randomPreferenceIndex = Math.floor(Math.random()*14);
				this.randomTaggingVerifyingTimeIndex = Math.floor(Math.random()*5);
				this.tagAndVerifyDelayStart = new Date().getTime();
				this.task = 0; //0 for tagging, 1 for verifying
				this.startDelayStart = new Date().getTime();
				this.startDelay = addDelay? startDelayData[Math.floor(Math.random()*42)] : 50;
				this.theta = 0;
				this.saveSpeed = 0;
				
				this.randomAccelIndex = Math.floor(Math.random()*47);
				if (this.randomAccelIndex >= 1  &&  this.randomAccelIndex <= 15)
					this.randomAccelIndex = 0;
				else if (this.randomAccelIndex >= 16  &&  this.randomAccelIndex <= 25)
					this.randomAccelIndex = 1;
				else if (this.randomAccelIndex >= 26  &&  this.randomAccelIndex <= 43)
					this.randomAccelIndex = 2;
				else if (this.randomAccelIndex >= 44  &&  this.randomAccelIndex <= 47)
					this.randomAccelIndex = 3;
					
				this.chooseTarget();
			}
			start(addDelay) {
			/* Choose the first target, then wait for a random amount of time,
			 * before moving toward the target. For now, just wait 500 ms.
			 */
				this.initialize(addDelay);
				this.lastRole = "null";
				handleFlash();
				vaTagAndVerify();
				if (addDelay) this.update();
			}
			
			chooseTarget() {
			/* Choose the current target for the virtual agent. */
				var vaTarget = [];
				var tagTarget = [];
				var verifyTarget = [];
				var thereAreNoAvailableTargets = true;
				for (var i = 0; i <= 19; i++) {
					if ((targetTracker[i] == 0) || (targetTracker[i] == 2)) thereAreNoAvailableTargets = false;
				}
				if (thereAreNoAvailableTargets) {
					vaTarget = [1000, 3500, 0];
				}
				else {
					tagTarget = this.closestTag();
					verifyTarget = this.closestVerify();
					var random = Math.floor(Math.random()*101);
					//console.log("Chance to verify: " + preferenceData[this.randomPreferenceIndex] + " and number: " + random/100);
					if ((random/100) < preferenceData[this.randomPreferenceIndex]) {
						vaTarget = verifyTarget;
					}
					else {
						vaTarget = tagTarget;
					}
				}
				this.target = {x: vaTarget[0], y: vaTarget[1], index: vaTarget[2]};
				if (targetTracker[this.target.index] == 0) this.task = 0;
				else if (targetTracker[this.target.index] == 2) this.task = 1;
				this.startingDistanceToTarget = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
				this.estimatedTime = (Math.sqrt((accelerationProportion[this.randomAccelIndex] * this.startingDistanceToTarget)/0.015))/30; //this is an underestimate, I think because it assumes most efficient path. Based on physics by the way.
			}
			
			closestTag() {
				var tagTarget = [];
				var leastDistance = 10000;
				var nextDistance;
				for (var i = 0; i <= 19; i++) {
					if (targetTracker[i] == 0) {
						nextDistance = this.distance(this.position.x, this.position.y, targetsCoords[i][0], targetsCoords[i][1]);
						if (nextDistance < leastDistance) {
							leastDistance = nextDistance;
							tagTarget = [targetsCoords[i][0], targetsCoords[i][1], i];
						}
					}
				}
				if (tagTarget.length == 0) {
					return this.closestVerify();
				}
				else {
					return tagTarget;
				}
			}
							
			closestVerify() {
				var verifyTarget = [];
				var leastDistance = 10000;
				var nextDistance;
				for (var i = 0; i <= 19; i++) {
					if (i == lastTargetIndex && this.fastForward) continue; //don't go after the new verifying point if you're fast forwarding
					if (targetTracker[i] == 2) {
						nextDistance = this.distance(this.position.x, this.position.y, targetsCoords[i][0], targetsCoords[i][1]);
						if (nextDistance < leastDistance) {
							leastDistance = nextDistance;
							verifyTarget = [targetsCoords[i][0], targetsCoords[i][1], i];
						}
					}
				}
				if (verifyTarget.length == 0) {
					return this.closestTag();
				}
				else {
					return verifyTarget;
				}
			}
			
			chooseDirection() {
				var angle = Math.atan2((this.target.y - (this.position.y + 4412)) * -1, this.target.x - (this.position.x + 14));
				return angle;
			}
			
			findPath(startDistance) {
				var options = [];
				var startDistance = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
				if (startDistance<100) {
					return this.chooseDirection();
				}
				for (var tryDirection = 0; tryDirection <= 23; tryDirection++){
					for (var steps = 0; steps < 1000; steps += 10) {
						if (inside([(this.position.x + steps*Math.cos(tryDirection*0.26)), (this.position.y - steps*Math.sin(tryDirection*0.26))], vaCanalTriacontapentagon)){
							var endDistance = this.distance(this.position.x + steps*Math.cos(tryDirection*0.26), this.position.y - steps*Math.sin(tryDirection*0.26), this.target.x, this.target.y);
							if (endDistance < startDistance) options[tryDirection] = steps;
							else options[tryDirection] = 0;
						}
						else break;
					}
				}
				var pathAngle = (options.indexOf(Math.max(...options)))*0.2618;
				return pathAngle;
			}
			
			distance(vaX, vaY, targetX, targetY) {
				vaX += 14;
				vaY += 4412;
				return Math.sqrt((vaX - targetX)*(vaX - targetX) + (vaY - targetY)*(vaY - targetY));
			}
			
			update() {
				/* Decide whether or not to accelerate and decide what direction to
				   go.
				 */
				var endTime3 = new Date().getTime();
				if ((this.counter == 0) && ((endTime3 - this.startDelayStart) < (this.startDelay)) && (!this.fastForward)) {
					window.setTimeout(this.update.bind(this), (1000/60));
					socket.emit('vaMove', {x: 0, y: 0});
					return;
				}
				
				var currentDistanceToTarget = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
				var progress = 1-(currentDistanceToTarget)/this.startingDistanceToTarget;
				this.estimatedTimeLeft = this.estimatedTime * (currentDistanceToTarget/this.startingDistanceToTarget);
				if (progress <= accelerationData[this.randomAccelIndex][this.counter]) {
					this.magnitude = this.counter%2==0? this.magnitude + 0.03 : this.magnitude - 0.03;
				}
				else this.counter++;
				if (this.magnitude < 0.03) this.magnitude = 0;
				if (this.magnitude > this.saveSpeed) 
					this.killDistance = (this.magnitude * this.magnitude * (100/6)); 
				else 						
					this.killDistance -= this.magnitude;
				
				
				var fuzz = Math.random()*0.3;
				var cosFuzz = Math.cos(this.theta + 1.57);				
								
				if ((currentDistanceToTarget>85) && (inside([this.position.x + this.magnitude * Math.cos(this.findPath()), this.position.y - this.magnitude * Math.sin(this.findPath())], vaCanalTriacontapentagon))) {
					//The number above is the distance at which it should bounce back. For 0.99 to 1.01, (this.startingDistanceToTarget/100)
					this.angle = this.findPath();
					this.saveSpeed = this.magnitude;
					this.position.x += this.magnitude * Math.cos(this.angle);
					this.position.y -= this.magnitude * Math.sin(this.angle);
					socket.emit('vaMove', {x: this.magnitude * Math.cos(this.angle), y: this.magnitude * Math.sin(this.angle)});
					this.onTarget = false;
				}				
				else if (currentDistanceToTarget<=85 && this.killDistance > 4) {
					this.counter = accelerationData[this.randomAccelIndex].length - 1;
					if (this.magnitude > 0.3  &&  !inside([this.position.x + this.magnitude * Math.cos(this.angle+fuzz+cosFuzz), this.position.y - this.magnitude * Math.sin(this.angle+fuzz+cosFuzz)], vaCanalTriacontapentagon)) {
						this.angle += 3.14;
					}
					if (inside([this.position.x + this.magnitude * Math.cos(this.angle+fuzz+cosFuzz), this.position.y - this.magnitude * Math.sin(this.angle+fuzz+cosFuzz)], vaCanalTriacontapentagon)) {
						if (currentDistanceToTarget>35  &&  this.killDistance <= 85) this.angle = this.chooseDirection();
						this.position.x += this.magnitude * Math.cos(this.angle+fuzz+cosFuzz);
						this.position.y -= this.magnitude * Math.sin(this.angle+fuzz+cosFuzz);
						socket.emit('vaMove', {x: this.magnitude * Math.cos(this.angle+fuzz+cosFuzz), y: this.magnitude * Math.sin(this.angle+fuzz+cosFuzz)});
						this.onTarget = false;
						this.theta += 0.04;
					}
				}
				else if (currentDistanceToTarget < 35  &&  inside([this.position.x, this.position.y], vaCanalTriacontapentagon)) {
					this.onTarget = true;
					socket.emit('vaMove', {x: 0, y: 0});
				}
				if (!this.fastForward) {
					window.setTimeout(this.update.bind(this), (1000/60));
					console.log("updating");
				}
				else if (this.fastForward) {
					window.setTimeout(this.update.bind(this), (1000/600));
					console.log("fastforward updating");
				}
			}
		}
		
		
		
		
		/*
		*/
		
		
		

		var interval;
		var stick = [0, 0];
		var aButton = false;
		var accelButton = false;
		var gamepads = [];
		var gpRecorder = [50, 470, 0, 0]
		var gpSpriteCoords = [50, 470];
		var magnitude = 0;
		var direction = [0, 0];
		var saveDirection = [0,0];
		var angle = 1.57;
		if (readCookie("gpRecorder0") != null) {
			console.log("there be cookies");
			gpRecorder[0] = parseInt(readCookie("gpRecorder0")); 
			gpRecorder[1] = parseInt(readCookie("gpRecorder1")); 
			gpRecorder[2] = parseInt(readCookie("gpRecorder2")); 
			gpRecorder[3] = parseInt(readCookie("gpRecorder3")); 
			gpSpriteCoords[0] = parseInt(readCookie("gpSpriteCoords0"));
			gpSpriteCoords[1] = parseInt(readCookie("gpSpriteCoords1"));
			canvasLeftMargin = parseInt(readCookie("canvasLeftMargin"));
			canvasTopMargin = parseInt(readCookie("canvasTopMargin"));
			miniSprite1coords[0] = parseInt(readCookie("miniSprite1coords0"));
			miniSprite1coords[1] = parseInt(readCookie("miniSprite1coords1"));			
			miniSprite2coords[0] = parseInt(readCookie("miniSprite2coords0"));
			miniSprite2coords[1] = parseInt(readCookie("miniSprite2coords1"));
			lastTargetIndex = parseInt(readCookie("lastTargetIndex"));
			imageId = parseInt(readCookie("imageId"));
			targetTracker = JSON.parse(readCookie("targetTracker"));
			lastRole = readCookie("lastRole");
			log = localStorage.getItem("userLog");
			targetsVerified = parseInt(readCookie("targetsVerified"));
						
			var startTime = parseInt(readCookie("startTime"));
			var temp = new Date().getTime();
			var temp2 = parseInt(readCookie("elapsedTime"));
			timeSpentTaggingVerifying = temp - (temp2 + startTime); //Va has this much time to do things.
			var estimatedTimeLeft = parseInt(readCookie("vaEstimatedTimeLeft"))*1000; //Va time to target. Underestimate.
			
			var va = new VirtualAgent(parseInt(readCookie("vaPosX")), parseInt(readCookie("vaPosY")));
			va.start(false);
			targetInitializer();
			updateTargets();
			
			va.fastForward = true;
			va.chooseTarget(); //need to rechoose, so that it doesn't pick the point you just finished
			window.setTimeout(function() {va.fastForward = false}, (((timeSpentTaggingVerifying/1000)*60)+248)/0.184); ///Preferably, only start this when the page is fully loaded, and make the delay timeSpentTaggingVerifying/10.
			va.update(); //now it loops on its own.

			
			/*console.log(timeSpentTaggingVerifying + " and " + estimatedTimeLeft);

			if (timeSpentTaggingVerifying < estimatedTimeLeft) { //va cannot reach target, get closer
				console.log("scenario1");
				var radius = (timeSpentTaggingVerifying / (1000/60)) * 3 //multiplier is supposed to be average speed while you are off page.
				var angle2 = 0;
				for (; angle2 <= 6.30; angle2+=0.26) {
					if (inside([this.position.x + radius * Math.cos(angle), this.position.y - radius * Math.sin(angle)], vaCanalTriacontapentagon))
						break;
				}
				va.position.x = 286;
				va.position.y = 4300;//FIGURE OUT WHY YOU CAN'T SET COORDINATES. LOOK AT ELEMENT COORDINATES WITH DEV TOOLS.
			}
			else if (parseInt(readCookie("vaTask")) == 0) {
				if (timeSpentTaggingVerifying < (estimatedTimeLeft + tagTimeData[va.randomTaggingVerifyingTimeIndex]*1000)) { //va reaches target, begins tagging
					console.log("scenario2");
				}
				else if (timeSpentTaggingVerifying > (estimatedTimeLeft + tagTimeData[va.randomTaggingVerifyingTimeIndex]*1000)) { //va reaches target, finishing tagging, appears nearby
					console.log("scenario3");
				}
			}					
			else if (parseInt(readCookie("vaTask")) == 1) { 
				if (timeSpentTaggingVerifying < (estimatedTimeLeft + verifyTimeData[va.randomTaggingVerifyingTimeIndex]*1000)) { //va reaches target, begins verifying
				}
				else if (timeSpentTaggingVerifying > (estimatedTimeLeft + verifyTimeData[va.randomTaggingVerifyingTimeIndex]*1000)) { //va reaches target, finishing verifying, appears nearby
				}
			}
			
			
			targetInitializer();
	
			/*if (JSON.parse(readCookie("vaOnTarget"))) {
				var va = new VirtualAgent(parseInt(readCookie("vaPosX")), parseInt(readCookie("vaPosY")));
				va.start(false);
			}			
			else if (!JSON.parse(readCookie("vaOnTarget"))) {
				//must prepare for not on target but target gone.
				var va = new VirtualAgent(gpRecorder[0] - 30, gpRecorder[1] + 30);
				va.start(false, true);
				va.verifyHack = true;
			}
			va.onTarget = JSON.parse(readCookie("vaOnTarget"));
			
			
			if (va.onTarget) {
				va.target.index = readCookie("vaTargetIndex");
				if (parseInt(readCookie("vaTask")) == 0) {
					tagTargets[va.target.index].remove();
					targetSprites[va.target.index].remove();
					targetTracker[va.target.index] = 1;
					
					userVerifyTargets[va.target.index] = document.createElement("IMG");
					userVerifyTargets[va.target.index].setAttribute("id", "userVerifyTarget" + va.target.index);
					divWrapper.appendChild(userVerifyTargets[va.target.index]);
					targetSprites[va.target.index] = document.createElement("IMG");
					targetSprites[va.target.index].setAttribute("id", "miniTarget" + va.target.index);
					divWrapper.appendChild(targetSprites[va.target.index]);
					new Target(targetsCoords[va.target.index][0], targetsCoords[va.target.index][1], "userVerifyTarget", va.target.index, targetTracker[va.target.index]);
				
					va.lastRole = "tagging";
				}
				else if (parseInt(readCookie("vaTask")) == 1) {
					vaVerifyTargets[va.target.index].remove();
					targetSprites[va.target.index].remove();
					targetTracker[va.target.index] = 3;
					
					va.lastRole = "verifying";
				}
				va.initialize(false);
			}
			else if (!va.onTarget) {
				miniSprite2coords[0] += ((va.position.x - parseInt(readCookie("vaPosX")))*0.047);
				miniSprite2coords[1] += ((va.position.y - parseInt(readCookie("vaPosY")))*0.045);
			}*/
			va.lastRole = readCookie("vaLastRole");
			vaLog = localStorage.getItem("vaLog");
			
			updateClock();
			updateScore();
		}
		else {
			var startTime = new Date().getTime();
			updateClock();
			updateScore();
			targetInitializer();
			var va = new VirtualAgent(20, 550);
			va.start(true);
		}
		
		function targetInitializer() {
			for (var i = 0; i <= 19; i++) {
				if (targetTracker[i] == 0) {
					tagTargets[i] = document.createElement("IMG");
					tagTargets[i].setAttribute("id", "tagTarget" + i);
					divWrapper.appendChild(tagTargets[i]);
					targetSprites[i] = document.createElement("IMG");
					targetSprites[i].setAttribute("id", "miniTarget" + i);
					divWrapper.appendChild(targetSprites[i]);
					new Target(targetsCoords[i][0], targetsCoords[i][1], "tagTarget", i, targetTracker[i]);
				}				
				else if (targetTracker[i] == 1) {
					userVerifyTargets[i] = document.createElement("IMG");
					userVerifyTargets[i].setAttribute("id", "userVerifyTarget" + i);
					divWrapper.appendChild(userVerifyTargets[i]);
					targetSprites[i] = document.createElement("IMG");
					targetSprites[i].setAttribute("id", "miniTarget" + i);
					divWrapper.appendChild(targetSprites[i]);
					new Target(targetsCoords[i][0], targetsCoords[i][1], "userVerifyTarget", i, targetTracker[i]);
				}				
				else if (targetTracker[i] == 2) {
					vaVerifyTargets[i] = document.createElement("IMG");
					vaVerifyTargets[i].setAttribute("id", "vaVerifyTarget" + i);
					divWrapper.appendChild(vaVerifyTargets[i]);
					targetSprites[i] = document.createElement("IMG");
					targetSprites[i].setAttribute("id", "miniTarget" + i);
					divWrapper.appendChild(targetSprites[i]);
					new Target(targetsCoords[i][0], targetsCoords[i][1], "vaVerifyTarget", i, targetTracker[i]);
				}
				else if (targetTracker[i] == 3) continue;
			}
			updateTargets();
		}
		userSprite.style.left = gpSpriteCoords[0] + "px";
		userSprite.style.top = gpSpriteCoords[1] + "px";
		canvas.style.marginLeft = canvasLeftMargin + "px";
		canvas.style.marginTop = canvasTopMargin + "px";
		miniSprite1.style.left = miniSprite1coords[0] + "px";
		miniSprite1.style.top = miniSprite1coords[1] + "px";
		miniSprite2.style.left = miniSprite2coords[0] + "px";
		miniSprite2.style.top = miniSprite2coords[1] + "px";
		
		
		
		/*
		*/

		
		
		
		
		if (!('ongamepadconnected' in window)) {
			interval = setInterval(pollGamepads, 500);
		}
		function pollGamepads() {
			gamepads = navigator.getGamepads();
			for (var i = 0; i < gamepads.length; i++) {
				var gp = gamepads[i];
				if (gp) {
					console.log("Gamepad connected at index " + gp.index + ": " + gp.id + ". It has " + gp.buttons.length + " buttons and " + gp.axes.length + " axes.");
					clearInterval(interval);
				}
			}
			if ((gamepads[0]) != "undefined") {
				updateGP();
				gameLoop();
				ultraRecorder();
				vaUltraRecorder();
			}
		}
		function updateGP() {
				gamepads = navigator.getGamepads();
				stick[0] = ((gamepads[0]).axes[0]);
				stick[1] = ((gamepads[0]).axes[1]);
				aButton = (gamepads[0]).buttons[0].pressed;
				accelButton = (gamepads[0]).buttons[5].pressed;
				setTimeout(updateGP, (1000/30));
		}
	
		function gameLoop() {
			if (accelButton) {
				magnitude += 0.03;
			}
			else{
				if (magnitude < 0.01) magnitude = 0;
				else magnitude -= 0.03;
			}
			 
			if ((stick[0] < 0.5 && stick[0] > -0.5) && (stick[1] < 0.5 && stick[1] > -0.5)) {
				direction[0] = saveDirection[0];
				direction[1] = saveDirection[1];
			}
			else {
				direction[0] = stick[0] / (Math.sqrt(stick[0] * stick[0] + stick[1] * stick[1]));
				direction[1] = stick[1] / (Math.sqrt(stick[0] * stick[0] + stick[1] * stick[1]));
				saveDirection[0] = direction[0];
				saveDirection[1] = direction[1];
			}
			
			angle = Math.floor((Math.acos(direction[0] / (Math.sqrt(direction[0] * direction[0] + direction[1] * direction[1]))))/0.0349);
			if (direction[1] > 0) angle *= -1;

			var endTime = new Date().getTime();
			if ((endTime-startTime) > 3000) handleTargets();
			
			if (inside([(gpRecorder[0] + magnitude*2*direction[0]), (gpRecorder[1] + magnitude*2*direction[1])], canalTriacontapentagon)){
				logCookie();
				socket.emit('gpMove', {x1: gpRecorder[0], y1: gpRecorder[1]});
			}
			else 
				magnitude = 1;
			
			if (elapsedTime > 420000) {
				logger();
				vaLogger();
			}
			window.setTimeout(gameLoop, (1000/60));
		}

		socket.on('gpUpdateMap', function(msg) {
			function gpShifter() {
			if (gpSpriteCoords[0] > 400  &&  gpSpriteCoords[1] < 300)
				gpHandleShift(magnitude*Math.abs(direction[0]), magnitude*Math.abs(direction[1]));
			else if (gpSpriteCoords[0] > 400)
				gpHandleShift(magnitude*Math.abs(direction[0]), 0);
			else if (gpSpriteCoords[1] < 300)
				gpHandleShift(0, magnitude*Math.abs(direction[1]));
			if ((gpSpriteCoords[0] < 300)  &&  (gpSpriteCoords[1] > 400))
				gpHandleShift(-magnitude*Math.abs(direction[0]), -magnitude*Math.abs(direction[1]));
			else if (gpSpriteCoords[0] < 300)
				gpHandleShift(-magnitude*Math.abs(direction[0]), 0);
			else if (gpSpriteCoords[1] > 400)
				gpHandleShift(0, -magnitude*Math.abs(direction[1]));
			}
			function gpHandleShift(x, y) {
				gpRecorder[2] += x;
				gpRecorder[3] -= y;
				gpSpriteCoords[0] -= x;
				gpSpriteCoords[1] += y;
				gpRecorder[0] = gpSpriteCoords[0] + gpRecorder[2];			
				gpRecorder[1] = gpSpriteCoords[1] + gpRecorder[3];
				if (socket.io.engine.id == clientContainer[0]) {
					canvasLeftMargin -= x;
					canvasTopMargin += y;
					canvas.style.marginLeft = canvasLeftMargin + "px";
					canvas.style.marginTop = canvasTopMargin + "px";
					userSprite.style.left = gpSpriteCoords[0] + "px";
					userSprite.style.top = gpSpriteCoords[1] + "px";
					updateTargets();
				}
				else if (socket.io.engine.id == clientContainer[1]) {
					userSprite.style.left = gpSpriteCoords[0] - gpRecorder[2] - recorder2[2] + "px";
					userSprite.style.top = gpSpriteCoords[1] - gpRecorder[3] - recorder2[3]+ "px";
				}
			}
			gpShifter();
			gpSpriteCoords[0] += magnitude * direction[0];
			gpSpriteCoords[1] += magnitude * direction[1];
			gpRecorder[0] = gpSpriteCoords[0] + gpRecorder[2];			
			gpRecorder[1] = gpSpriteCoords[1] + gpRecorder[3];
			if (socket.io.engine.id == clientContainer[0]) {
				userSprite.style.left = gpSpriteCoords[0] + 'px';
				userSprite.style.top = gpSpriteCoords[1] + 'px';
			}
			else if (socket.io.engine.id == clientContainer[1]) {
				userSprite.style.left = gpRecorder[0] - recorder2[2] + "px";
				userSprite.style.top = gpRecorder[1] - recorder2[3] + "px";
			}
			userSprite.style.transform = "rotate(" + angle*-2 +"deg)";
			miniSprite1coords[0] += (magnitude*direction[0]*0.047);
			miniSprite1coords[1] += (magnitude*direction[1]*0.045);
			miniSprite1.style.left = miniSprite1coords[0] + "px";
			miniSprite1.style.top = miniSprite1coords[1] + "px";
		});
		
		
		/*
		*/

		
		
		
		function updateTargets (x, y) {
			for (var i = 0; i<=19; i++) {
				if (targetTracker[i] == 3) continue;
				if (targetTracker[i] == 0) {
					tagTargets[i].style.left = tagTargets[i].xPos - gpRecorder[2] + "px";
					tagTargets[i].style.top = tagTargets[i].yPos - gpRecorder[3] + "px";
				}
				else if (targetTracker[i] == 1) {
					userVerifyTargets[i].style.left = userVerifyTargets[i].xPos - gpRecorder[2] + "px";
					userVerifyTargets[i].style.top = userVerifyTargets[i].yPos - gpRecorder[3] + "px";						
				}
				else if (targetTracker[i] == 2) {
					vaVerifyTargets[i].style.left = vaVerifyTargets[i].xPos - gpRecorder[2] + "px";
					vaVerifyTargets[i].style.top = vaVerifyTargets[i].yPos - gpRecorder[3] + "px";	
				}				
			}
		}

		function handleTargets() {
			for (var i = 0; i <= 19; i++) {
				if ((targetTracker[i] == 0)  &&  (Math.abs(gpRecorder[0] - tagTargets[i].xPos) < 50)  &&  (Math.abs(gpRecorder[1] - tagTargets[i].yPos) < 50)  &&  (magnitude<1)  &&  (aButton)) {
					tagTargets[i].remove();
					targetSprites[i].remove();
					targetTracker[i] = 2;
					lastRole = "tagging";
					lastTargetIndex = i;
					imageId++;
					logCookie();
					logger();
					vaLogger();

					/*var xhr = new XMLHttpRequest();
					xhr.open("GET", "/tagRedirect");
					xhr.send(null);*/
					window.location.href = "http://localhost:3000/tag.html";
				}
			}
			for (var i = 0; i <= 19; i++) {
				if ((targetTracker[i] == 1)  &&  (Math.abs(gpRecorder[0] - userVerifyTargets[i].xPos) < 50)  &&  (Math.abs(gpRecorder[1] - userVerifyTargets[i].yPos) < 50)  &&  (magnitude<1)  &&  (aButton)) {
					userVerifyTargets[i].remove();
					targetSprites[i].remove();
					targetTracker[i] = 3;
					lastRole = "verifying";
					imageId++;
					targetsVerified++;
					updateScore();
					logCookie();
					logger();
					vaLogger();
					
					
					/*var xhr = new XMLHttpRequest();
					xhr.open("GET", "/verifyRedirect");
					xhr.send(null);*/
					window.location.href = "http://localhost:3000/verify.html";
				}
			}
		}
		
		
		function inside(point, polygon) {
			var boatX = point[0]+15, boatY = point[1]+4400;
			var inside = false;
			for (var i=0, j=polygon.length-1; i<polygon.length; j=i++) {
				var xi = polygon[i][0], yi = polygon[i][1];
				var xj = polygon[j][0], yj = polygon[j][1];
			
				var intersect = (((yi>boatY) != (yj>boatY)) && (boatX<(xj-xi)*(boatY-yi)/(yj-yi)+xi));
				if (intersect) 
					inside = !inside;
			}
			return inside;
		}
		
		
		/*
		*/
		
		
		
		
		socket.on("vaUpdateMap", function(msg) {
			va.sprite.style.left = va.position.x - gpRecorder[2] + "px";
			va.sprite.style.top = va.position.y - gpRecorder[3] + "px";
			miniSprite2coords[0] += (msg.x*0.047);
			miniSprite2coords[1] -= (msg.y*0.045);
			miniSprite2.style.left = miniSprite2coords[0] + "px";
			miniSprite2.style.top = miniSprite2coords[1] + "px";
			//va.sprite.style.transform = "rotate(" + va.angle*(180/3.14)*-2 +"deg)";
		});
		
		function handleFlash() {
			if (va.onTarget) {
				if (va.sprite.style.visibility == "hidden") {
					va.sprite.style.visibility = "visible";
					miniSprite2.style.visibility = "visible";
				}
				else {
					va.sprite.style.visibility = "hidden";
					miniSprite2.style.visibility = "hidden";
				}
			}
			else {
				va.sprite.style.visibility = "visible";
				miniSprite2.style.visibility = "visible";
			}
			window.setTimeout(handleFlash, 500);
		}
		
		function vaTagAndVerify() {
			if (!va.onTarget) {
				va.TagAndVerifyDelayStart = new Date().getTime();
			}
			else if (va.onTarget) {
				var endTime2 = new Date().getTime();
				var timeToTag = tagTimeData[va.randomTaggingVerifyingTimeIndex]*1000;
				var timeToVerify = verifyTimeData[va.randomTaggingVerifyingTimeIndex]*1000;
				if (va.fastForward) {
					timeToTag = timeToTag/10;
					timeToVerify = timeToVerify/10;
				}
				if ((va.task == 0)  &&  ((endTime2 - va.TagAndVerifyDelayStart) >= (timeToTag))) {
					tagTargets[va.target.index].remove();
					targetSprites[va.target.index].remove();
					targetTracker[va.target.index] = 1;
					
					userVerifyTargets[va.target.index] = document.createElement("IMG");
					userVerifyTargets[va.target.index].setAttribute("id", "userVerifyTarget" + va.target.index);
					divWrapper.appendChild(userVerifyTargets[va.target.index]);
					targetSprites[va.target.index] = document.createElement("IMG");
					targetSprites[va.target.index].setAttribute("id", "miniTarget" + va.target.index);
					divWrapper.appendChild(targetSprites[va.target.index]);
					new Target(targetsCoords[va.target.index][0], targetsCoords[va.target.index][1], "userVerifyTarget", va.target.index, targetTracker[va.target.index]);
					updateTargets();
					
					va.lastRole = "tagging";
					va.initialize(true);
				}
				else if ((va.task == 1)  &&  ((endTime2 - va.TagAndVerifyDelayStart) >= (timeToVerify))) {
					vaVerifyTargets[va.target.index].remove();
					targetSprites[va.target.index].remove();
					targetTracker[va.target.index] = 3;
					targetsVerified++;
					updateScore();
					updateTargets();
					
					va.lastRole = "verifying";
					va.initialize(true);
				}
			}
			if(va.fastForward)
				window.setTimeout(vaTagAndVerify, 10);
			else 
				window.setTimeout(vaTagAndVerify, 100);
		}

		
		function ultraRecorder() {
			endTime = new Date();
			elapsedTime = endTime - startTime;
			log += '\n' + truncate(gpRecorder[0], 1) + "," + truncate(gpRecorder[1], 1) + "," + targetsVerified + "," + truncate(elapsedTime, 1) + "," + lastRole + "," + sessionStorage.getItem("num-tags") + "," + sessionStorage.getItem("num-verified-tags");

			localStorage.setItem("userLog", log);
			window.setTimeout(ultraRecorder, 100);
		}
		function vaUltraRecorder() {
			var endTime2 = new Date();
			elapsedTime = endTime2 - startTime;
			vaLog += '\n' + truncate(va.position.x, 1) + "," + truncate(va.position.y, 1) + "," + truncate(elapsedTime, 1) + "," + va.lastRole;
			
			localStorage.setItem("vaLog", vaLog);
			window.setTimeout(vaUltraRecorder, 100);
		}
		function truncate (num, digits) {
			var numS = num.toString(),
				decPos = numS.indexOf('.'),
				substrLength = decPos == -1 ? numS.length : 1 + decPos + digits,
				trimmedResult = numS.substr(0, substrLength),
				finalResult = isNaN(trimmedResult) ? 0 : trimmedResult;
			return parseFloat(finalResult);
		}
		function logger() {
			var xhr = new XMLHttpRequest();
			xhr.open("POST", "/save");
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.send("record=" +  log);
		}
		function vaLogger() {
			var xhr = new XMLHttpRequest();
			xhr.open("POST", "/vaSave");
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.send("vaRecord=" +  vaLog);
		}
		function logCookie() {
				document.cookie = "gpRecorder0=" + gpRecorder[0] + ";";
				document.cookie = "gpRecorder1=" + gpRecorder[1] + ";";
				document.cookie = "gpRecorder2=" + gpRecorder[2] + ";";
				document.cookie = "gpRecorder3=" + gpRecorder[3] + ";";
				document.cookie = "gpSpriteCoords0=" + gpSpriteCoords[0] + ";";
				document.cookie = "gpSpriteCoords1=" + gpSpriteCoords[1] + ";";
				document.cookie = "canvasLeftMargin=" + canvasLeftMargin + ";";
				document.cookie = "canvasTopMargin=" + canvasTopMargin + ";";		
				document.cookie = "miniSprite1coords0=" + miniSprite1coords[0] + ";";		
				document.cookie = "miniSprite1coords1=" + miniSprite1coords[1] + ";";
				document.cookie = "miniSprite2coords0=" + miniSprite2coords[0] + ";";		
				document.cookie = "miniSprite2coords1=" + miniSprite2coords[1] + ";";
				document.cookie = "targetTracker=" + "[" + targetTracker.join(",") + "]";
				document.cookie = "lastTargetIndex=" + lastTargetIndex + ";";
				document.cookie = "targetsVerified=" + targetsVerified + ";";
				document.cookie = "vaPosX=" + va.position.x + ";";
				document.cookie = "vaPosY=" + va.position.y + ";";
				document.cookie = "imageId=" + imageId + ";";
				document.cookie = "lastRole=" + lastRole + ";"; 
				document.cookie = "vaLastRole=" + va.lastRole + ";"; 
				document.cookie = "startTime=" + startTime + ";";
				document.cookie = "elapsedTime=" + elapsedTime + ";";
				document.cookie = "vaOnTarget=" + va.onTarget + ";";
				document.cookie = "vaTargetX=" + va.target.x + ";";
				document.cookie = "vaTargetY=" + va.target.y + ";";
				document.cookie = "vaTargetIndex=" + va.target.index + ";";
				document.cookie = "vaTask=" + va.task + ";";
				document.cookie = "vaEstimatedTimeLeft=" + va.estimatedTimeLeft + ";";
		}
		function readCookie(key){
			var result;
			return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? (result[1]) : null;
		}
		
		function updateClock() {
			//this doesn't actually work around the 60 or 00 second mark.
			var minutes = 6 - Math.floor((elapsedTime / 1000)/60);
			var seconds = 60 - Math.floor((elapsedTime / 1000) % 60);
			if (seconds == 60) {
				seconds = 0;
				minutes++;
			}
			if (seconds >= 10) {
				clock.innerHTML = '' + minutes + ':' + seconds;
			}
			else {
				clock.innerHTML = '' + minutes + ':0' + seconds;
			}
			window.setTimeout(updateClock, 1000);
		}
		function updateScore() {
			scoreDiv.innerHTML = "Verified images: " + targetsVerified;
		}
		
		})(window, document);
    </script>
  </body>
</html>