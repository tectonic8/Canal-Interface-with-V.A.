<!doctype html>
<html>
  <head>
    <title>Objective One</title>
    <style>
		#bigWrapper {position:fixed; right: 10; bottom: 10; width:700px; height:700px; margin: 0 auto; overflow:hidden; z-index:2}
		#clockDiv {position:relative; width:50px; height:50px; margin: 0 auto; overflow:hidden; font-size: 20px; z-index:99; font-family: Arial, Helvetica, sans-serif;}
		#scoreDiv {position:relative; width:200px; height:50px; margin: 0 auto; padding-left: 127px; overflow:hidden; font-size: 1.5em; z-index:100; font-family: Arial, Helvetica, sans-serif;}
		#boatSprite1 {position:absolute; width:50px; height:35px; transition:none; transform-origin: 25px 17.5px; z-index: 95}
		#boatSprite2 {position:absolute; top:550px; left: 20px; width:50px; height:35px; transition: none; z-index: 93}
		#gowanusMap {position:relative; right: 10px; bottom: 10px; width:700px; height:700px; z-index: 4}
		#canvas {width:5100px; height:6600px; transition: none; z-index:1}
		#minimap {width:200px, height:228px; position:absolute; left:500px; top: 500px; border:1px solid #000000; z-index:79}
		#miniSprite1 {position:absolute; left:500px; top:690px; width:20px; height:20px; z-index:86}
		#miniSprite2 {position:absolute; left:500px; top:690px; width:20px; height:20px; z-index:85}
		.target {position: absolute; z-index:83}
    button {position: relative; z-index: 101; margin: 0 auto; font-size: 20px; font-family: Arial, Helvetica, sans-serif;}
	</style>
  </head>
  <body>
	<div id="bigWrapper">
		<canvas id="minimap" width="200" height="228"></canvas>
		<canvas id="canvas" width="5100" height="6600"></canvas>
		<img id="gowanusMap" src="canal3.png" alt="canalMap">
		<img id="boatSprite1" src="boatSprite1.png" alt="boatIcon">
		<img id="boatSprite2" src="boatSprite2.png" alt="boatIcon2">
		<img id="miniSprite1" src="miniSprite1.png">
		<img id="miniSprite2" src="miniSprite2.png">
	</div>
	<div id="clockDiv"></div>
	<div id="scoreDiv"></div>
    <script>
		(function(window, document) {
		
			var ELEMENT_IDS = {
				canvas: "canvas",
				minimap: "minimap",
				userSprite: "boatSprite1",
				buddySprite: "boatSprite2",
				gowanusMap: "gowanusMap",
				miniSprite1: "miniSprite1",
				miniSprite2: "miniSprite2",
				divWrapper: "bigWrapper",
				clock: "clockDiv",
				scoreDiv: "scoreDiv"
			};
			var EVENTS = {
				LOAD:      'load',
				MOUSEDOWN: 'mousedown',
				MOUSEMOVE: 'mousemove',
				MOUSEUP:   'mouseup'
			};
			var canvas = document.getElementById(ELEMENT_IDS.canvas);
			var minimap = document.getElementById(ELEMENT_IDS.minimap);
			var gowanusMap = document.getElementById(ELEMENT_IDS.gowanusMap);
			var divWrapper = document.getElementById(ELEMENT_IDS.divWrapper);
			var clock = document.getElementById(ELEMENT_IDS.clock);
			var scoreDiv = document.getElementById(ELEMENT_IDS.scoreDiv);
			var ctx = canvas.getContext("2d");
			var minimapContext = minimap.getContext("2d");
			var canvasTopMargin = -4400; //The map is scrolled by changing the top and left margins.
			var canvasLeftMargin = 0;
			var loadTime = 0; //Load time is factored into how long the va should fast forward
			gowanusMap.addEventListener(EVENTS.LOAD, function(event) {
				ctx.drawImage(this, 0, 0); 
				canvas.style.marginTop = canvasTopMargin + "px";
				minimapContext.drawImage(this, 0, 480, 4066, 5000, 0, 0, 200, 228);
        if (!readCookie("gpRecorder0")) {
          var button = document.createElement('button');
          button.addEventListener('click', function(event) {
            button.parentElement.removeChild(button);
            window.addEventListener('unload', function(event) {
              localStorage.setItem("userLog", log);
              localStorage.setItem("vaLog", vaLog);
              logCookie();
            });
            startTime = new Date().getTime();
            var f00 = Math.random();
            var behavior = (f00 < 0.5) ? 0 : 1;
            console.log('Virtual agent behavior roll is: ' + f00);
            console.log('Virtual agent behavior is type: ' + behavior);
            va = new VirtualAgent(20, 550, behavior);
            va.start(true);//true meaning start with the delay.
            interval = setInterval(pollGamepads, 500);
          });
          button.textContent = 'start';
          document.body.appendChild(button);
        } else {
          interval = setInterval(pollGamepads, 500);
          va.startDelayStart = new Date().getTime();
//			    va.tagAndVerifyDelayStart = new Date().getTime();
					va.update();
          vaTagAndVerify();
        }
			});

      if (!readCookie('deleted') && readCookie("gpRecorder0") != null) {
        document.addEventListener("DOMContentLoaded", function(event) {//not sure why it doesn't work without this part
          targetInitializer(); //targetInitializer creates the targets.

          if (va.target.index === lastTargetIndex) { // User took VA's tag target, so it will have to go for another
            va.targetValid = false;
          }

          if (vaLog === '') {
            vaLog = localStorage.getItem("vaLog");
          }
          
          va.fastForward = true;
			  	var frameCount = timeSpentTaggingVerifying * 60/1000;
				  for (var t = 0; t < frameCount; ++t) {
					  va.update(); //fastForwarding
            vaTagAndVerify();
				  }
				  va.fastForward = false;

					if (targetTracker[va.target.index] == 0) va.task = 0;
					else if (targetTracker[va.target.index] == 2) va.task = 1;
          
          localStorage.setItem("vaLog", vaLog);
          
          updateTargets();
          
          /*va.startDelayStart = new Date().getTime();
          va.tagAndVerifyDelayStart = new Date().getTime();
				  va.update();
          vaTagAndVerify();*/
          handleFlash();
        });
			}
      
			var userSprite = document.getElementById(ELEMENT_IDS.userSprite);
			var buddySprite = document.getElementById(ELEMENT_IDS.buddySprite);
			var miniSprite1 = document.getElementById(ELEMENT_IDS.miniSprite1);
			var miniSprite2 = document.getElementById(ELEMENT_IDS.miniSprite2);
			var canalTriacontapentagon = [[0, 2318], [84, 2318], [430, 1755], [552, 1617], [656, 1533], [812, 1499], [1055, 1531], [1292, 1583], [1495, 1265], [1510, 1067], [1899, 327], [1972, 365], [1584, 1101], [1580, 1286], [1623, 1319], [1527, 1474], [1483, 1445], [1344, 1663], [1370, 1754], [1611, 1909], [1566, 1975], [1311, 1817], [1279, 1683], [906, 1583], [766, 1579], [1098, 1797], [1050, 1863], [675, 1626], [569, 1721], [809, 1878], [770, 1948], [525, 1793], [75, 2480], [144, 2626], [0, 2655]]; //this is the polygon of the canal. The tolerance might be a little too high, since I didn't go exactly around the perimeter.
			var vaCanalTriacontapentagon = [[0, 2318], [84, 2318], [430, 1755], [552, 1617], [656, 1533], [812, 1499], [1055, 1531], [1292, 1583], [1495, 1265], [1510, 1067], [1899, 327], [1972, 365], [1584, 1101], [1580, 1286], [1623, 1319], [1527, 1474], [1483, 1445], [1344, 1663], [1279, 1683], [906, 1583], [766, 1579], [675, 1626], [569, 1721], [525, 1793], [75, 2480], [144, 2626], [0, 2655]]; //this is used just for the va so it can't enter the side canals. Also, it is actually a icosikaiheptagon, not a triacontapentagon, but the former seems a little cumbersome.
			for (var i = 0; i<= 34; i++) {//The coordinates are multiplied because they were recorded for the map image that was half the size.
				canalTriacontapentagon[i][0] *= 2;
				canalTriacontapentagon[i][1] *= 2;
			}		
			for (var i = 0; i<= 26; i++) {
				vaCanalTriacontapentagon[i][0] *= 2;
				vaCanalTriacontapentagon[i][1] *= 2;
			}
			var miniSprite1coords = [500, 690];
			var miniSprite2coords = [500, 690];
			var rotate = 0;
			var log = '';
			var vaLog = '';
			
			//var targetsCoords = [[227, 4694], [557, 4133], [1045, 3506], [1377, 3121], [2149, 3169], [2605, 3327], [2965, 2694], [3107, 2358], [3333, 1724], [3711, 960], [401, 4409], [708, 3924], [1158, 3256], [1828, 3079], [2786, 3014], [3206, 1962], [3471, 1451], [3600, 1214], [2428, 3215], [863, 3688]]; //absolute positions for 20 targets. See "canal3 with targets.png" in the hide folder to see what this looks like. Also, these aren't really ordered. The first 10 were in order, but the next ten were just put wherever there was space on the map. So target 19 is not necessarily at the end of the canal.
      var targetsCoords = [
        [ 227, 4694],
        [ 401, 4409],
        [ 557, 4133],
        [ 708, 3924],
        [ 863, 3688],
        [1045, 3506],
        [1158, 3256],
        [1377, 3121],
        [1828, 3079],
        [2149, 3169],
        [2428, 3215],
        [2605, 3327],
        [2786, 3014],
        [2965, 2694],
        [3107, 2358],
        [3206, 1962],
        [3333, 1724],
        [3471, 1451],
        [3600, 1214],
        [3711,  960]
      ]; //absolute positions for 20 targets. See "canal3 with targets.png" in the hide folder to see what this looks like. Also, these aren't really ordered. The first 10 were in order, but the next ten were just put wherever there was space on the map. So target 19 is not necessarily at the end of the canal.
      
      var anchorPoints = [{x: 1603, y: 3100}, {x: 2605, y: 3277}, {x: 3157, y: 2160}];
			var tagTargets = [];//One array for each type of target. One array for the minimap sprites.
			var userVerifyTargets = [];
			var vaVerifyTargets = [];
			var targetSprites = [];
			for (var i = 0; i<= 19; i++) { //this is necessary because the targets are appended to the wrapper, not the document body so they are a little offset I thnk.
				targetsCoords[i][0] -= 9;
				targetsCoords[i][1] -= 9;
			}
			var targetTracker = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; //0 means untagged, 1 means user verifies, 2 means va verifies, 3 means nonexistant
      var tagTracker    = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Keep track of how many tags are added to an image
			
			var accelerationData = [[0.129, 0.155, 0.168, 0.182, 0.195, 0.209, 0.223, 0.238, 0.252, 0.266, 0.281, 0.295, 0.324, 0.351, 0.364, 0.389, 0.893, 1], [0.513, 0.664, 0.692, 0.841, 0.899, 1], [0.493, 0.471, 0.731, 0.733, 0.734, 0.738, 0.92, 1], [0.72, 1]]; //I haven't implemented making a decreasing progress work. Also, these numbers represent the proportion through the canal at which point the user switched from acceleration to deceleration or vice-versa.
			var accelerationProportion = [0.768, 0.599, 0.644, 0.72]; //This is how much time is spent accelerating for each of the 4 representative models.
			var preferenceData = [0.088, 0.696]; //1 in the last index was made by me, it will not be randomly selected, only used when I want it to 100% verify
			var startDelayData = [500, 3599, 500, 1200, 801, 499, 890, 700, 900, 2700, 2401, 2598, 800, 800, 2701, 1000, 301, 3700, 4100, 4401, 6300, 4101, 4801, 4500, 2101, 6099, 5299, 5100, 3900, 3100, 6300, 4799, 3801, 4800, 4601, 3703, 5000, 9501, 3903, 5899, 4300, 4700];
			var tagTimeData = [26.7, 12.7, 10.4, 27.4, 7.7]; 
			var verifyTimeData = [6.2, 2.8, 3.2, 8.8, 3.9];
			
			var imageId = 1; //This is used to tell the tag and verify html which image to load, instead of using an html template system.
			var lastRole = null;
			var elapsedTime = 0;
			var timeSpentTaggingVerifying = 0;
			var lastTargetIndex = null;
			var targetsVerified = 0; //score
			var tagCount = 0;
			var verifyCount = 0;
		
			class Target {
				constructor(x, y, id, index, type) { //type is 0, 1, or 2, representing tagged, user verify, and va verify.
					var target = document.getElementById(id + index);
					target.setAttribute("width", 50);
					target.setAttribute("height", 50);
					target.setAttribute("class", "target");
					target.xPos = x - 14;
					target.yPos = y - 4412;
					target.style.left = target.xPos + "px";
					target.style.top = target.yPos + "px";
					
					var targetSprite = document.getElementById("miniTarget" + index);
					targetSprite.setAttribute("width", 15);
					targetSprite.setAttribute("height", 15);
					targetSprite.setAttribute("class", "target");
					targetSprite.style.left = (x-107)*0.048 + 501 + "px";
					targetSprite.style.top = (y-4864)*0.046 + 691 + "px";
					if (type == 0) {
						target.setAttribute("src", "target.png");
						targetSprite.setAttribute("src", "miniTarget.png");
					}
					if (type == 1) {
						target.setAttribute("src", "target2.png");
						targetSprite.setAttribute("src", "target2.png");
					}
					if (type == 2) {
						target.setAttribute("src", "target3.png");
						targetSprite.setAttribute("src", "target3.png");
					}
				}
			}

			class VirtualAgent {
				constructor(x, y, behavior) {
					this.behavior = behavior;
					this.sprite = document.getElementById(ELEMENT_IDS.buddySprite);
					this.position = {x:x, y:y};
					this.fastForward = false;
					this.targetValid = true;
				}
				
				initialize(addDelay, fastForward) {
					this.magnitude = 0;
					this.onTarget = false;
					this.counter = 0;
					this.randomTaggingVerifyingTimeIndex = Math.floor(Math.random()*5);
					this.tagAndVerifyDelayStart = new Date().getTime();
					this.task = 0; //0 for tagging, 1 for verifying
					this.startDelayStart = new Date().getTime();
					this.startDelay = addDelay? startDelayData[Math.floor(Math.random()*42)] : 0; //after a target or when the page loads, it initializes with the start delay. If you come back to the page in the middle of its movement, it will not have a start delay.
					this.theta = 0;
					this.saveSpeed = 0;
					
					this.randomAccelIndex = Math.floor(Math.random()*47);
					if (this.randomAccelIndex >= 1  &&  this.randomAccelIndex <= 15) //This system handles the probabilities of getting each of the 4 representative acceleration patterns.
						this.randomAccelIndex = 0;
					else if (this.randomAccelIndex >= 16  &&  this.randomAccelIndex <= 25)
						this.randomAccelIndex = 1;
					else if (this.randomAccelIndex >= 26  &&  this.randomAccelIndex <= 43)
						this.randomAccelIndex = 2;
					else if (this.randomAccelIndex >= 44  &&  this.randomAccelIndex <= 47)
						this.randomAccelIndex = 3;
						
					this.chooseTarget();
					this.targetValid = true;  

          if (fastForward) {
            this.framesRequiredDelay = this.startDelay / 1000 * 60;
            this.framesElapsed = 0;
            this.framesElapsedDelay = 0;
          }
				}

        saveState() {
          var framesElapsed = (new Date().getTime() - va.vaTagAndVerifyDelayStart) * 1000 * 60;
          var framesElapsedDelay = (new Date().getTime() - va.startDelayStart) * 1000 * 60;
          var framesRequiredDelay = va.startDelay * 1000 * 60;
          return {
            magnitude: this.magnitude,
            counter: this.counter,
            randomTaggingVerifyingTimeIndex: this.randomTaggingVerifyingTimeIndex,
            task: this.task,
            startDelay: this.startDelay,
            theta: this.theta,
            saveSpeed: this.saveSpeed,
            randomAccelIndex: this.randomAccelIndex,
            target: this.target,
            startingDistanceToTarget: this.startingDistanceToTarget,
            killDistance: this.killDistance,
            angle: this.angle,
            onTarget: this.onTarget,
            lastRole: this.lastRole,
            tagAndVerifyDelayStart: this.tagAndVerifyDelayStart,
            framesElapsed: framesElapsed,
            framesElapsedDelay: framesElapsedDelay,
            framesRequiredDelay: framesRequiredDelay
          };
        }

        restoreState(state) {
          this.magnitude = state.magnitude;
          this.counter = state.counter;
          this.randomTaggingVerifyingTimeIndex = state.randomTaggingVerifyingTimeIndex;
          this.task = state.task;
          this.startDelay = state.startDelay;
          this.theta = state.theta;
          this.saveSpeed = state.saveSpeed;
          this.randomAccelIndex = state.randomAccelIndex;
          this.target = state.target;
          this.startingDistanceToTarget = state.startingDistanceToTarget;
          this.killDistance = state.killDistance;
          this.angle = state.angle;
          this.onTarget = state.onTarget;
          this.lastRole = state.lastRole;
          this.tagAndVerifyDelayStart = state.tagAndVerifyDelayStart;
          this.framesElapsed = state.framesElapsed;
          this.framesElapsedDelay = state.framesElapsedDelay;
        }

				start(addDelay) {
				/* Choose the first target, then wait for a random amount of time,
				 * before moving toward the target. For now, just wait 500 ms.
				 */
					this.initialize(addDelay, false); //delay is optional, depending on when the va is being started. it's a boolean.
          //this.chooseTarget();
					handleFlash();
					vaTagAndVerify();
					if (addDelay) this.update();
				}
				
				chooseTarget() {
				/* Choose the current target for the virtual agent. */
					var vaTarget = null;
					var tagTarget = null;
					var verifyTarget = null;
					var thereAreNoAvailableTargets = true;
					for (var i = 0; i <= 19; i++) {
						if ((targetTracker[i] == 0) || (targetTracker[i] == 2)) thereAreNoAvailableTargets = false;
					}
					if (thereAreNoAvailableTargets) {
						vaTarget = [1000, 3500, 0]; //Just a random location to go when it's done. Otherwise it will search for targets until it breaks.
					}
					else {
						tagTarget = this.closestTag();
						verifyTarget = this.closestVerify();
            var ddd = Math.random();
            console.log('Target roll is: ' + ddd);
						if (ddd < preferenceData[this.behavior]) {
							vaTarget = tagTarget;
						} else {
							vaTarget = verifyTarget;
						}
					}
					this.target = {x: vaTarget[0], y: vaTarget[1], index: vaTarget[2]};
					if (targetTracker[this.target.index] == 0) this.task = 0;
					else if (targetTracker[this.target.index] == 2) this.task = 1;
					//this.startingDistanceToTarget = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
          this.startingDistanceToTarget = this.distanceToTarget();
				}
				
        distanceToTarget() {
          /* Case 0: the virtual agent is to the left of all anchor points. */
          if (this.position.x <= anchorPoints[0].x) {
            /* Sub case 0: the target is to the left of all anchor points. */
            if (this.target.x <= anchorPoints[0].x) {
              return this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
            /* Sub case 1: the target is between the first and second anchor points. */ 
            } else if (this.target.x <= anchorPoints[1].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[0].x, anchorPoints[0].y) +
                this.distance(anchorPoints[0].x, anchorPoints[0].y, this.target.x, this.target.y);
            /* Sub case 2: the target is between the second and third anchor points. */
            } else if (this.target.x <= anchorPoints[2].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[0].x, anchorPoints[0].y) +
                this.distance(anchorPoints[0].x, anchorPoints[0].y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, this.target.x, this.target.y);
            /* Sub case 3: the target is to the right of all anchor points. */
            } else {
              return this.distance(this.position.x, this.position.y, anchorPoints[0].x, anchorPoints[0].y) +
                this.distance(anchorPoints[0].x, anchorPoints[0].y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, anchorPoints[2].x, anchorPoints[2].y) +
                this.distance(anchorPoints[2].x, anchorPoints[2].y, this.target.x, this.target.y);
            }
          /* Case 1: the virtual agent is between the first and second anchor points. */          
          } else if (this.position.x <= anchorPoints[1].x) {
            /* Sub case 0: the target is to the left of all anchor points. */
            if (this.target.x <= anchorPoints[0].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[0].x, anchorPoints[0].y) +
                this.distance(anchorPoints[0].x, anchorPoints[0].y, this.target.x, this.target.y);
            /* Sub case 1: the target is between the first and second anchor points. */ 
            } else if (this.target.x <= anchorPoints[1].x) {
              return this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
            /* Sub case 2: the target is between the second and third anchor points. */
            } else if (this.target.x <= anchorPoints[2].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, this.target.x, this.target.y);
            /* Sub case 3: the target is to the right of all anchor points. */
            } else {
              return this.distance(this.position.x, this.position.y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, anchorPoints[2].x, anchorPoints[2].y) +
                this.distance(anchorPoints[2].x, anchorPoints[2].y, this.target.x, this.target.y);
            }
          /* Case 2: the virtual agent is between the second and third anchor points. */
          } else if (this.position.x <= anchorPoints[2].x) {
            /* Sub case 0: the target is to the left of all anchor points. */
            if (this.target.x <= anchorPoints[0].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, anchorPoints[0].x, anchorPoints[0].y) +
                this.distance(anchorPoints[0].x, anchorPoints[0].y, this.target.x, this.target.y);
            /* Sub case 1: the target is between the first and second anchor points. */ 
            } else if (this.target.x <= anchorPoints[1].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, this.target.x, this.target.y);
            /* Sub case 2: the target is between the second and third anchor points. */
            } else if (this.target.x <= anchorPoints[2].x) {
              return this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
            /* Sub case 3: the target is to the right of all anchor points. */
            } else {
              return this.distance(this.position.x, this.position.y, anchorPoints[2].x, anchorPoints[2].y) +
                this.distance(anchorPoints[2].x, anchorPoints[2].y, this.target.x, this.target.y);
            }
          /* Case 3: the virtual agent is to the right of all anchor points. */
          } else {
            /* Sub case 0: the target is to the left of all anchor points. */
            if (this.target.x <= anchorPoints[0].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[2].x, anchorPoints[2].y) +
                this.distance(anchorPoints[2].x, anchorPoints[2].y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, anchorPoints[0].x, anchorPoints[0].y) +
                this.distance(anchorPoints[0].x, anchorPoints[0].y, this.target.x, this.target.y);
            /* Sub case 1: the target is between the first and second anchor points. */ 
            } else if (this.target.x <= anchorPoints[1].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[2].x, anchorPoints[2].y) +
                this.distance(anchorPoints[2].x, anchorPoints[2].y, anchorPoints[1].x, anchorPoints[1].y) +
                this.distance(anchorPoints[1].x, anchorPoints[1].y, this.target.x, this.target.y);
            /* Sub case 2: the target is between the second and third anchor points. */
            } else if (this.target.x <= anchorPoints[2].x) {
              return this.distance(this.position.x, this.position.y, anchorPoints[2].x, anchorPoints[2].y) +
                this.distance(anchorPoints[2].x, anchorPoints[2].y, this.target.x, this.target.y);
            /* Sub case 3: the target is to the right of all anchor points. */
            } else {
              return this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
            }
          }
        }
        
				closestTag() {
					var tagTarget = null;
					var leastDistance = 10000;
					var nextDistance = 0;
					for (var i = 0; i <= 19; i++) {
						if (!va.targetValid && i == lastTargetIndex) continue;
            			//if (i == lastTargetIndex) continue; // don't go after a point the user is tagging.
						if (targetTracker[i] == 0) {
							nextDistance = this.distance(this.position.x, this.position.y, targetsCoords[i][0], targetsCoords[i][1]);
							if (nextDistance < leastDistance) {
								leastDistance = nextDistance;
								tagTarget = [targetsCoords[i][0], targetsCoords[i][1], i];
							}
						}
					}
					if (tagTarget === null) { //if there are no tag targets, return a verify target, even if it isn't the preference.
						return this.closestVerify();
					}
					else {
						return tagTarget;
					}
				}
								
				closestVerify() {
					var verifyTarget = null;
					var leastDistance = 10000;
					var nextDistance = 0;
					for (var i = 0; i <= 19; i++) {
						if (!va.targetValid && i == lastTargetIndex) continue;
						if (i == lastTargetIndex && this.fastForward) continue; //don't go after the new verifying point if you're fast forwarding
						if (targetTracker[i] == 2) {
							nextDistance = this.distance(this.position.x, this.position.y, targetsCoords[i][0], targetsCoords[i][1]);
							if (nextDistance < leastDistance) {
								leastDistance = nextDistance;
								verifyTarget = [targetsCoords[i][0], targetsCoords[i][1], i];
							}
						}
					}
					if (verifyTarget === null) {//if there are no verify targets, return a tag target, even if it wasn't the original preference.
						return this.closestTag();
					}
					else {
						return verifyTarget;
					}
				}
				
				chooseDirection() { //finds the exact angle to the target
					var angle = Math.atan2((this.target.y - (this.position.y + 4412)) * -1, this.target.x - (this.position.x + 14)); //adding 14 to the x coordinate and 4412 to the y coordinate is how you get from the recorders to the global position. Probably because the canvas starts at roughly that offset.
					return angle;
				}
				
				findPath() {
					var options = [];
					//var startDistance = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
          var startDistance = this.distanceToTarget();
					if (startDistance < 85) { //if va is close to target, just go to the target, don't navigate through canal.
						return this.chooseDirection();
					}
					for (var tryDirection = 0; tryDirection <= 23; tryDirection++){ //This is movement algorithm. Start by looking in 24 evenly spaced directions.
						if (inside([(this.position.x + this.magnitude * Math.cos(tryDirection * Math.PI / 12)), (this.position.y - this.magnitude * Math.sin(tryDirection * Math.PI / 12))], vaCanalTriacontapentagon)) {
              for (var steps = 0; steps < 1000; steps += 10) { //see what is the farthest distance you can go in each of those 24 directions
                if (inside([(this.position.x + steps * Math.cos(tryDirection * Math.PI / 12)), (this.position.y - steps * Math.sin(tryDirection * Math.PI / 12))], vaCanalTriacontapentagon)){ //0.26 is pi/12
                  //var endDistance = this.distance(this.position.x + steps*Math.cos(tryDirection * Math.PI / 12), this.position.y - steps*Math.sin(tryDirection * Math.PI / 12), this.target.x, this.target.y);
                  var tmpPos = {x: this.position.x, y: this.position.y};
                  this.position.x = this.position.x + steps*Math.cos(tryDirection * Math.PI / 12);
                  this.position.y = this.position.y - steps*Math.sin(tryDirection * Math.PI / 12);
                  //var endDistance = this.distance(this.position.x + steps*Math.cos(tryDirection * Math.PI / 12), this.position.y - steps*Math.sin(tryDirection * Math.PI / 12), this.target.x, this.target.y);
                  var endDistance = this.distanceToTarget();
                  if (endDistance < startDistance) options[tryDirection] = steps; //if it takes va closer, save it.
                  else options[tryDirection] = 0;
                  this.position.x = tmpPos.x;
                  this.position.y = tmpPos.y
                }
                else break;
              }
            } else {
              options[tryDirection] = 0;
            }
					}
          if (options.every(function(option) { return 0 === option; })) {
            return this.chooseDirection();
          } else {
            var pathAngle = (options.indexOf(Math.max(...options))) * Math.PI / 12; //save the biggest number in the array, multiply the index by pi/12 to get the angle.
            return pathAngle;
          }
				}
				
				distance(vaX, vaY, targetX, targetY) { //just distance formula
					vaX += 14;
					vaY += 4412;
					return Math.sqrt((vaX - targetX)*(vaX - targetX) + (vaY - targetY)*(vaY - targetY));
				}
				
				update() {
					va.lastRole = "navigating";

					var oldX = this.position.x;
					var oldY = this.position.y;

					if (this.targetValid) {
						var endTime3 = new Date().getTime();
						if ((this.counter == 0) && ((endTime3 - this.startDelayStart) < (this.startDelay)) && (!this.fastForward)) { //this handles the delay.
							vaUltraRecorder();
							window.setTimeout(this.update.bind(this), (1000/60));
							vaUpdateMap({x: 0, y: 0});
							return;
						}

						if (this.fastForward && this.counter === 0 && this.framesElapsedDelay < this.framesRequiredDelay) {
							vaUltraRecorder();
							this.framesElapsedDelay += 1; 
							return;
						}

						var currentDistanceToTarget = this.target.mapProportion - this.mapProportion;
						var progress = 1 - currentDistanceToTarget / this.startingDistanceToTarget;

						// The magnitude will now tell us whether we're going left or right 
						if (progress <= accelerationData[this.randomAccelIndex][this.counter]) {
							this.accel = 0.03 * (this.counter % 2 === 0 ? 1 : -1); //since the data is a list of proportions at which there is switch, this code figure out if it is supposed to acc or decel
							this.accel = (currentDistanceToTarget > 0 ? this.accel : -this.accel); // The current distance now tells us which direction the target is in, relative to the virtual agent
							this.magnitude += this.accel; 
						}

						else this.counter++;

						if (Math.abs(this.magnitude) < 0.03) {
							this.magnitude = 0;
							this.accel = 0;
						}

						if (Math.abs(this.magnitude) > Math.abs(this.saveSpeed)) //killDistance handles the excess speed va has at the end.
							this.killDistance = (this.magnitude * this.magnitude * (100/6)); //Speed divided by deceleration gives the number of frames it would take to decelerate. Speed/2 is average speed going from speed to 0. Frames it would take to decelerate times average speed = distance it would take to get to 0 speed. Formula simplified.
						else 						
							this.killDistance -= Math.abs(this.magnitude); //if va starts decelerating,  decrease the amount of distance va needs to slow down.

						if (Math.abs(currentDistanceToTarget) > 85) {
							this.saveSpeed = this.magnitude;

							this.mapProportion += this.magnitude; 
							if (this.mapProportion > 1) // I'm not sure if it's possible to go past the the domain of the last function, but just in case, it'll stop at the end.
								this.mapProportion = 1;

							this.functionIndex = 0;
							for (i = 0; i < xBreak.length(); ++i) { // Which function is the VA in?
								if (xBreak[i] < this.mapProportion)
									this.functionIndex++;
								else
									break;
							}

							this.position.x = this.xPP[this.functionIndex](this.mapProportion);
							this.position.y = this.yPP[this.functionIndex](this.mapProportion);
							vaUpdateMap({x: this.position.x - oldX, y: this.position.y - oldY});
							this.onTarget = false;
						}
						else if (Math.abs(currentDistanceToTarget) <= 85 && Math.abs(this.killDistance) > 4) {
							this.counter = accelerationData[this.randomAccelIndex].length - 1; //If va is near the target, make sure the counter is set so that it's only decelerating at this point.
							this.saveSpeed = this.magnitude;

							this.mapProportion += this.magnitude; 
							if (this.mapProportion > 1)
								this.mapProportion = 1;

							this.functionIndex = 0;
							for (i = 0; i < xBreak.length(); ++i) {
								if (xBreak[i] < this.mapProportion)
									this.functionIndex++;
								else
									break;
							}

							this.position.x = this.xPP[this.functionIndex](this.mapProportion);
							this.position.y = this.yPP[this.functionIndex](this.mapProportion);
							vaUpdateMap({x: this.position.x - oldX, y: this.position.y - oldY});
							this.onTarget = false;	
						}
						else if (Math.abs(currentDistanceToTarget) >= 35 && Math.abs(currentDistanceToTarget) <=85) {
							// We still have this branch in case the VA's target is taken and stops close enough to its new target that it can't accelerate enough
							this.accel = 0.06 * (currentDistanceToTarget > 0 ? 1 : -1); // Accelerate to the target anyways if we stopped without enough kill distance
							this.magnitude += this.accel;
			  				this.saveSpeed = this.magnitude;

			  				this.mapProportion += this.magnitude;
							if (this.mapProportion > 1)
								this.mapProportion = 1;

							this.functionIndex = 0;
							for (i = 0; i < xBreak.length(); ++i) { 
								if (xBreak[i] < this.mapProportion)
									this.functionIndex++;
								else
									break;
							}

							this.position.x = this.xPP[this.functionIndex](this.mapProportion);
							this.position.y = this.yPP[this.functionIndex](this.mapProportion);
							vaUpdateMap({x: this.position.x - oldX, y: this.position.y - oldY});
							this.onTarget = false;
						}

						if (Math.abs(currentDistanceToTarget) < 35 && Math.abs(this.magnitude) < 0.06) {
							this.onTarget = true;
							if (this.task === 0) {
								this.lastRole = 'tagging';              
							} else {
								this.lastRole = 'verifying';
							}
							vaUpdateMap({x: 0, y: 0});
						}

					}
					else {
						this.accel = 0.03 * (this.target.mapProportion > this.mapProportion ? 1 : -1);
						if (Math.abs(this.magnitude) < 0.03) {
							this.magnitude = 0;
							this.accel = 0;
							va.initialize(false, this.fastForward);
						}
						else { 
							this.accel = 0.03 * (this.magnitude < 0 ? 1 : -1); // To slow down, bring the magnitude closer to 0
							this.magnitude += this.accel;
							this.saveSpeed = this.magnitude;
							this.mapProportion += this.magnitude;

							if (this.mapProportion > 1)
								this.mapProportion = 1;

							this.functionIndex = 0;
							for (i = 0; i < xBreak.length(); ++i) { // In case we go into a new function while stopping
								if (xBreak[i] < this.mapProportion)
									this.functionIndex++;
								else
									break;
							}

							this.position.x = this.xPP[this.functionIndex](this.mapProportion);
							this.position.y = this.yPP[this.functionIndex](this.mapProportion);
							vaUpdateMap({x: this.position.x - oldX, y: this.position.y - oldY});
						}
					}

					vaUpdateMap({x: 0, y: 0});
					vaUltraRecorder();

					if (!this.fastForward) {
						window.setTimeout(this.update.bind(this), (1000/60));
					}
				}
			}

			var interval = null; //All the gamepad variables are initialized here.
			var stick = [0, 0];
			var aButton = false;
			var rightAccelButton     = false;
      var leftAccelButton      = false;
      var rightAccelButtonPrev = false;
      var leftAccelButtonPrev  = false;
      var impulseStartTime = 0;
			var gamepads = [];
			var gpIdx = -1;
      var gpRecorder = [50, 470, 0, 0] //gpRecorder is not the global coordinates or the local coordinates. It's the global coordinates with an offset x-14, y-4412. It records all the local movement.
			var gpSpriteCoords = [50, 470];
			var magnitude  = 0;
      var magnitude0 = 0;
      var userT     = 0;
      var userTPrev = 0;
      var userT0    = 0;
      var b = 0.1;
			var direction = [0, 0];
			var saveDirection = [0,0];
			var angle = 1.57;
			if (!readCookie('deleted') && readCookie("gpRecorder0") != null) { //this if-else handles saving the game using cookie. It only follows the cookies path if the user moved, not if there are cookies in general.
				console.log("there be cookies");
				gpRecorder[0] = parseInt(readCookie("gpRecorder0"));
				gpRecorder[1] = parseInt(readCookie("gpRecorder1")); 
				gpRecorder[2] = parseInt(readCookie("gpRecorder2")); 
				gpRecorder[3] = parseInt(readCookie("gpRecorder3")); 
				gpSpriteCoords[0] = parseInt(readCookie("gpSpriteCoords0"));
				gpSpriteCoords[1] = parseInt(readCookie("gpSpriteCoords1"));
				canvasLeftMargin = parseInt(readCookie("canvasLeftMargin"));
				canvasTopMargin = parseInt(readCookie("canvasTopMargin"));
				miniSprite1coords[0] = parseInt(readCookie("miniSprite1coords0"));
				miniSprite1coords[1] = parseInt(readCookie("miniSprite1coords1"));			
				miniSprite2coords[0] = parseInt(readCookie("miniSprite2coords0"));
				miniSprite2coords[1] = parseInt(readCookie("miniSprite2coords1"));
				lastTargetIndex = parseInt(readCookie("lastTargetIndex")); //lastTargetIndex is used so va doesn't go after the point you made during fastForwarding
				imageId = parseInt(readCookie("imageId")); 
				targetTracker = JSON.parse(readCookie("targetTracker"));
        tagTracker = JSON.parse(readCookie("tagTracker"));
				lastRole = readCookie("lastRole"); //this is for the log I think.
				log = localStorage.getItem("userLog"); //Cookies can't save things that are multiple lines, so I use localStorage instead.
        vaLog = localStorage.getItem("vaLog");
				targetsVerified = parseInt(readCookie("targetsVerified"));
				tagCount = parseInt(readCookie("tagCount"));
				verifyCount = parseInt(readCookie("verifyCount"));
				
        
        if (lastRole === "tagging") {
          tagTracker[lastTargetIndex] = parseInt(readCookie("numTags"));
        } else if (lastRole === "verifying") {
          targetsVerified += parseInt(readCookie("numVerifiedTags"));
        }
        lastRole = 'navigating';
        
				if (isNaN(targetsVerified)) { targetsVerified = 0; }
				if (isNaN(imageId)) { imageId = 15; }
				var startTime = parseInt(readCookie("startTime")); //startTime is always the time when the entire program first start.
				var temp = new Date().getTime();
				var temp2 = parseInt(readCookie("elapsedTime"));
				timeSpentTaggingVerifying = temp - (temp2 + startTime); //User was tagging/verifying for this long.
				        
				var va = new VirtualAgent(parseInt(readCookie("vaPosX")), parseInt(readCookie("vaPosY")), parseInt(readCookie("vaBehavior"))); //it is drawn onto the old position.
        va.restoreState(JSON.parse(readCookie("vaState"))); // restore va state for fast-forwarding.

//				targetInitializer(); //targetInitializer creates the targets.
//				updateTargets(); //updateTargets draws the targets.
				
				updateClock();
				updateScore();
			}
			else { //if there are no cookies:
        lastRole = 'navigating';
				var va = null;
        var startTime = 0;
        document.cookie = 'deleted=;expires=Thu, 01 Jan 1970 00:00:00 GMT';
        updateClock();
				updateScore();
        targetInitializer(); //targetInitializer creates the targets.
				updateTargets(); //updateTargets draws the targets.
			}
			
			function targetInitializer() { //I never really figured out how to use the Target class properly, so now I just use this method in conjunction with the class.
				for (var i = 0; i <= 19; i++) { //The way this is set up, each of the three target arrays are all length 20, they are just blank in the indices for which there is no target of that type. This is important for how the arrays are handled in other functions.
					if (targetTracker[i] == 0) {
						tagTargets[i] = document.createElement("IMG");
						tagTargets[i].setAttribute("id", "tagTarget" + i);
						divWrapper.appendChild(tagTargets[i]);
						targetSprites[i] = document.createElement("IMG");
						targetSprites[i].setAttribute("id", "miniTarget" + i);
						divWrapper.appendChild(targetSprites[i]); //If you attach it to the document body, it goes under the canvas, so I attached it to the div.
						new Target(targetsCoords[i][0], targetsCoords[i][1], "tagTarget", i, targetTracker[i]);
					}				
					else if (targetTracker[i] == 1) {
						userVerifyTargets[i] = document.createElement("IMG");
						userVerifyTargets[i].setAttribute("id", "userVerifyTarget" + i);
						divWrapper.appendChild(userVerifyTargets[i]);
						targetSprites[i] = document.createElement("IMG");
						targetSprites[i].setAttribute("id", "miniTarget" + i);
						divWrapper.appendChild(targetSprites[i]);
						new Target(targetsCoords[i][0], targetsCoords[i][1], "userVerifyTarget", i, targetTracker[i]);
					}				
					else if (targetTracker[i] == 2) {
						vaVerifyTargets[i] = document.createElement("IMG");
						vaVerifyTargets[i].setAttribute("id", "vaVerifyTarget" + i);
						divWrapper.appendChild(vaVerifyTargets[i]);
						targetSprites[i] = document.createElement("IMG");
						targetSprites[i].setAttribute("id", "miniTarget" + i);
						divWrapper.appendChild(targetSprites[i]);
						new Target(targetsCoords[i][0], targetsCoords[i][1], "vaVerifyTarget", i, targetTracker[i]);
					}
					else if (targetTracker[i] == 3) continue;
				}
//				updateTargets();
			}
			userSprite.style.left = gpSpriteCoords[0] + "px";
			userSprite.style.top = gpSpriteCoords[1] + "px";
			canvas.style.marginLeft = canvasLeftMargin + "px";
			canvas.style.marginTop = canvasTopMargin + "px";
			miniSprite1.style.left = miniSprite1coords[0] + "px";
			miniSprite1.style.top = miniSprite1coords[1] + "px";
			miniSprite2.style.left = miniSprite2coords[0] + "px";
			miniSprite2.style.top = miniSprite2coords[1] + "px";
			
			
			
			//All the initializing is done at this point.

			function pollGamepads() { //This searches for the gamepad at multiple indices. For some reason it isn't always at index 0.
				gamepads = navigator.getGamepads();
				for (var i = 0; i < gamepads.length; i++) {
					var gp = gamepads[i];
					if (gp) {
						console.log("Gamepad connected at index " + gp.index + ": " + gp.id + ". It has " + gp.buttons.length + " buttons and " + gp.axes.length + " axes.");
					
            if (gp.id.indexOf('STANDARD GAMEPAD Vendor: 046d') !== -1 && gp.id.indexOf("Product: c216") !== -1) {
              gpIdx = i;
              clearInterval(interval);
            }
          }
				}

				if (gpIdx !== -1) { //If the gamepad doesn't work, it probably wasn't at index 0, and this is the source of that problem.
					gameLoop();
				}
			}
		
			function gameLoop() {
				gamepads = navigator.getGamepads(); //in chrome, it needs to do this any time it wants input. The entire syntax for handling these gamepads seems to differ a lot between browsers.
        aButton = (gamepads[gpIdx]).buttons[0].pressed; //this is a boolean
        leftAccelButton  = (gamepads[gpIdx]).buttons[4].pressed;
        rightAccelButton = (gamepads[gpIdx]).buttons[5].pressed;
        if (rightAccelButton && !rightAccelButtonPrev && !leftAccelButton) {
          magnitude0 = magnitude + 0.03;
          userT0     = userT;
          impulseStartTime = Date.now();
        } else if (leftAccelButton && !leftAccelButtonPrev && !rightAccelButton) {
          magnitude0 = magnitude - 0.03;
          userT0     = userT;
          impulseStartTime = Date.now();
        }
        else{
          if (magnitude < 0.01 || magnitude > -0.01) {
            magnitude = 0;
          } else {
            var t = (Date.now() - impulseStartTime) / 1000;
            magnitude = magnitude0 * Math.exp(-b * t);
            userT = userT0 + magnitude0 / b * (1 - Math.exp(-b * t));
            var dx = d2x(userT) - d2x(userTPrev);
            var dy = d2y(userT) - d2y(userTPrev);
            angle = Math.atan2(dy, dx) * 180 / Math.PI;
          }
        }
        
//				angle = Math.floor((Math.acos(direction[0] / (Math.sqrt(direction[0] * direction[0] + direction[1] * direction[1]))))/0.0349); //angle is used to angle the user boat. 0.0349 means it moves in intervals of 2 degrees.
				handleTargets();
        
				gpUpdateMap();
				ultraRecorder();
				
        leftAccelButtonPrev  = leftAccelButton;
        rightAccelButtonPrev = rightAccelButton;
        userTPrev            = userT;
        
				if (elapsedTime > 420000) { //data is only logged at the end of the 7 minutes.
					elapsedTime = 420000;
					logger();
					vaLogger(true);
				} else {
					window.setTimeout(gameLoop, (1000/60));
				}
			}
      
      /*function rotateUser(clockwise) {
        if  (clockwise) {
          angle -= 2;
          if (angle <= -90) angle += 180;
        }
        else {
          //if (angle >= 178)
          angle += 2;
          if (angle >= 90) angle -= 180;
         }
        //if (angle < 0)  angle += 360;
      }*/

	//		socket.on('gpUpdateMap', function(msg) { //I don't really use the msg from the server. It's sort of a vestige from the dragging form of the program. You probably don't need to emit this either, since there's only one user. 
			function gpUpdateMap(msg) {
				function gpShifter() { //This shifts the canvas based on the local coordinates of the user. It shifts direction depending on what edge or corner you're on.
          if (gpSpriteCoords[0] < 300 && d2x(userT) < d2x(userTPrev)) {
            gpHandleShift(d2x(userT) - d2x(userTPrev), 0);
          }
          
          if (gpSpriteCoords[0] > 400 && d2x(userT) > d2x(userTPrev)) {
            gpHandleShift(d2x(userT) - d2x(userTPrev), 0);
          }
          
          if (gpSpriteCoords[1] < 300 && d2y(userT) < d2y(userTPrev)) {
            gpHandleShift(0, d2y(userT) - d2y(userTPrev));
          } 
          
          if (gpSpriteCoords[1] > 400 && d2y(userT) > d2y(userTPrev)) {
            gpHandleShift(0, d2y(userT) - d2y(userTPrev));
          }
				};
        
				function gpHandleShift(x, y) {
					gpRecorder[2] += x; //gpRecorder 2 and 3 are the total x and y shift of the canvas. 
					gpRecorder[3] -= y;
					gpSpriteCoords[0] -= x;
					gpSpriteCoords[1] += y;
					gpRecorder[0] = gpSpriteCoords[0] + gpRecorder[2]; //I only just noticed this adds up to 0. This should get deleted.			
					gpRecorder[1] = gpSpriteCoords[1] + gpRecorder[3];
					canvasLeftMargin -= x;
					canvasTopMargin += y;
					canvas.style.marginLeft = canvasLeftMargin + "px";
					canvas.style.marginTop = canvasTopMargin + "px";
					userSprite.style.left = gpSpriteCoords[0] + "px";
					userSprite.style.top = gpSpriteCoords[1] + "px";
					updateTargets();
				};
        
				gpShifter();
          gpSpriteCoords[0] += d2x(userT) - d2x(userTPrev);
          gpSpriteCoords[1] += d2y(userT) - d2y(userTPrev);
          gpRecorder[0] = gpSpriteCoords[0] + gpRecorder[2];	//local coordinates + canvas offset = relatively global coordinates (+14, +4412 offset)		
          gpRecorder[1] = gpSpriteCoords[1] + gpRecorder[3];
          userSprite.style.left = gpSpriteCoords[0] + 'px';
          userSprite.style.top = gpSpriteCoords[1] + 'px';
				  userSprite.style.transform = "rotate(" + angle + "deg)"; 
          miniSprite1coords[0] += (d2x(userT) - d2x(userTPrev)) * 0.047; //this changes the coordinates of the minisprite. I tried to do this intelligently by actually finding the ratio from the map to the minimap, but it didn't work so I just tried different numbers until it looked decent enough.
          miniSprite1coords[1] += (d2y(userT) - d2y(userTPrev)) * 0.045;
          miniSprite1.style.left = miniSprite1coords[0] + "px";
          miniSprite1.style.top = miniSprite1coords[1] + "px";
			};
			
      function d2x(d) {
          var omega = 4.980;
          var a0 = 1963;
          var a  = [-1216, -560.5, -307.1, -40.62, 113.2, 84.7 , 25.1  , 1.831 ];
          var b  = [-1129, -41   , 304.7 , 219.7 , 101.3, 28.59, -39.48, -29.42];
          var x = a0;
          for (var idx = 0; idx < a.length; ++idx) {
            x += a[idx] * Math.cos((idx + 1) * d * omega) + b[idx] * Math.sin((idx + 1) * d * omega);
          }
          return x;
        };
      
        function d2y(d) {
          var omega = 5.174;
          var a0 = 2839;
          var a  = [410.2, 808.3, 340.6, 312.9 , 125.8 , 47.16 , 2.847 , -5.913];
          var b  = [1281 , 448.8, 125  , -99.37, -85.81, -89.05, -45.36, -34.82];
          var y  = a0;
          for (var idx = 0; idx < a.length; ++idx) {
            y += a[idx] * Math.cos((idx + 1) * d * omega) + b[idx] * Math.sin((idx + 1) * d * omega);
          }
          return y;
        };
      
			/*
			*/

			function updateTargets (x, y) { //draws the targets.
				for (var i = 0; i<=19; i++) {
					if (targetTracker[i] == 3) continue;
					if (targetTracker[i] == 0) {
						tagTargets[i].style.left = tagTargets[i].xPos - gpRecorder[2] + "px";
						tagTargets[i].style.top = tagTargets[i].yPos - gpRecorder[3] + "px";
					}
					else if (targetTracker[i] == 1) {
						userVerifyTargets[i].style.left = userVerifyTargets[i].xPos - gpRecorder[2] + "px";
						userVerifyTargets[i].style.top = userVerifyTargets[i].yPos - gpRecorder[3] + "px";						
					}
					else if (targetTracker[i] == 2 && vaVerifyTargets[i] !== undefined) {
						vaVerifyTargets[i].style.left = vaVerifyTargets[i].xPos - gpRecorder[2] + "px";
						vaVerifyTargets[i].style.top = vaVerifyTargets[i].yPos - gpRecorder[3] + "px";	
					}				
				}
			}

			function handleTargets() { //This handles clicking on the targets.
				for (var i = 0; i <= 19; i++) {
					if (i == va.target.index  &&  va.onTarget) continue; //You can't steal a target va already started.
					if ((targetTracker[i] == 0)  &&  (Math.abs(gpRecorder[0] - tagTargets[i].xPos) < 50)  &&  (Math.abs(gpRecorder[1] - tagTargets[i].yPos) < 50)  &&  (magnitude<1)  &&  (aButton)) { //If it's a tag target, and you're close, and moving slow, and pressing the a button, it executes.
						tagTargets[i].remove();
						targetSprites[i].remove();
						targetTracker[i] = 2; //The target at this index will load as a va verifies target when it restarts.
						lastRole = "tagging"; //used in the log
						lastTargetIndex = i; 
						imageId++;
						tagCount++; //Used in the log
            ultraRecorder();
						logCookie();
						//logger(); //It also logs before targets, not just at the end of the 7 minutes.
						//vaLogger();
            localStorage.setItem("userLog", log);
            localStorage.setItem("vaLog", vaLog);
						window.location.replace('tag.html'); //I stopped using server requests since I stopped using html templates.
					}
				}
				for (var i = 0; i <= 19; i++) {
					if ((targetTracker[i] == 1)  &&  (Math.abs(gpRecorder[0] - userVerifyTargets[i].xPos) < 50)  &&  (Math.abs(gpRecorder[1] - userVerifyTargets[i].yPos) < 50)  &&  (magnitude<1)  &&  (aButton)) {
						userVerifyTargets[i].remove();
						targetSprites[i].remove();
						targetTracker[i] = 3;
						lastRole = "verifying";
						imageId++;
//						targetsVerified++;
						verifyCount++;
						updateScore();
            ultraRecorder();
						logCookie();
						//logger();
						//vaLogger();
						localStorage.setItem("vaLog", vaLog);
            localStorage.setItem("userLog", log);
						window.location.replace('verify.html');
					}
				}
			}
			
			
			function inside(point, polygon) { //This function checks if a point (array with x and y coordinate) is in a polygon (two-dimensional array). I copied it straight from stack overflow and have no idea how it works. 
				var boatX = point[0]+15, boatY = point[1]+4400; //The coordinates of the boat are for the top left corner I think, not the center, so they are tweaked a little from the (+14, +4412). Probably not tweaked well but still. 
				var inside = false;
				for (var i=0, j=polygon.length-1; i<polygon.length; j=i++) {
					var xi = polygon[i][0], yi = polygon[i][1];
					var xj = polygon[j][0], yj = polygon[j][1];
				
					var intersect = (((yi>boatY) != (yj>boatY)) && (boatX<(xj-xi)*(boatY-yi)/(yj-yi)+xi));
					if (intersect) 
						inside = !inside;
				}
				return inside;
			}
			
	//		socket.on("vaUpdateMap", function(msg) {
			function vaUpdateMap(msg) {
				va.sprite.style.left = va.position.x - gpRecorder[2] + "px";
				va.sprite.style.top = va.position.y - gpRecorder[3] + "px";
				miniSprite2coords[0] += (msg.x*0.047);
				miniSprite2coords[1] -= (msg.y*0.045);
				miniSprite2.style.left = miniSprite2coords[0] + "px";
				miniSprite2.style.top = miniSprite2coords[1] + "px";
				//va.sprite.style.transform = "rotate(" + va.angle*(180/3.14)*-2 +"deg)"; // I considered having have the va sprite rotate as well, but it looks bad with the current sprite
			};
			
			function handleFlash() { //This makes the va and it's minimap icon flash when its tagging to indicate that it is tagging/verifying. It loops independently of the other things.
				if (va.onTarget) {
					if (va.sprite.style.visibility == "hidden") {
						va.sprite.style.visibility = "visible";
						miniSprite2.style.visibility = "visible";
					}
					else {
						va.sprite.style.visibility = "hidden";
						miniSprite2.style.visibility = "hidden";
					}
				}
				else {
					va.sprite.style.visibility = "visible";
					miniSprite2.style.visibility = "visible";
				}
				window.setTimeout(handleFlash, 500);
			}
			
			function vaTagAndVerify() { //This handle the targets for the va
        if (va.fastForward) {
          if (va.onTarget) {
            var framesRequiredTag = tagTimeData[va.randomTaggingVerifyingTimeIndex] * 60;
            var framesRequiredVerify = verifyTimeData[va.randomTaggingVerifyingTimeIndex] * 60;
            // If enough frames elapsed, then update targets / score
            if (va.task === 0 && va.framesElapsed >= framesRequiredTag) {
              if (tagTargets[va.target.index]) {
                tagTargets[va.target.index].remove();
              }
              if (targetSprites[va.target.index]) {
                targetSprites[va.target.index].remove();
              }
              targetTracker[va.target.index] = 1;
              userVerifyTargets [va.target.index] = document.createElement('IMG');
              userVerifyTargets [va.target.index].setAttribute('id', 'userVerifyTarget' + va.target.index);
              divWrapper.appendChild(userVerifyTargets[va.target.index]);
              targetSprites[va.target.index] = document.createElement('IMG');
              targetSprites[va.target.index].setAttribute('id', 'miniTarget' + va.target.index);
              divWrapper.appendChild(targetSprites[va.target.index]);
              new Target(targetsCoords[va.target.index][0], targetsCoords[va.target.index][1], 'userVerifyTarget', va.target.index, targetTracker[va.target.index]);
              va.onTarget = false;
              va.initialize(true, true);              
              //va.chooseTarget();
            } else if (va.task === 1 && va.framesElapsed >= framesRequiredVerify) {
              vaVerifyTargets[va.target.index].remove();
              targetSprites[va.target.index].remove();
              targetTracker[va.target.index] = 3;
              targetsVerified += tagTracker[va.target.index];
                    
              va.onTarget = false;
              va.initialize(true, true);
              //va.chooseTarget();
            }
              va.framesElapsed += 1;
          }
          return;
        }
				if (!va.onTarget) {
					va.tagAndVerifyDelayStart = new Date().getTime(); //this time is constantly updated if you are not on the target so you get the exact start time when it is on the target
				}
				else if (va.onTarget) {
					var endTime2 = new Date().getTime();
					var timeToTag = tagTimeData[va.randomTaggingVerifyingTimeIndex]*1000; //there is only one random index for both of these because both arrays are the same size.
					var timeToVerify = verifyTimeData[va.randomTaggingVerifyingTimeIndex]*1000;
          console.log('Time tagging: ' + (endTime2 - va.tagAndVerifyDelayStart));
					if ((va.task == 0)  &&  ((endTime2 - va.tagAndVerifyDelayStart) >= (timeToTag))) {
						if (tagTargets[va.target.index]) { tagTargets[va.target.index].remove(); }
						if (targetSprites[va.target.index]) { targetSprites[va.target.index].remove(); }
						targetTracker[va.target.index] = 1; //this becomes a user verifies target.
						
						userVerifyTargets[va.target.index] = document.createElement("IMG");
						userVerifyTargets[va.target.index].setAttribute("id", "userVerifyTarget" + va.target.index);
						divWrapper.appendChild(userVerifyTargets[va.target.index]);
						targetSprites[va.target.index] = document.createElement("IMG");
						targetSprites[va.target.index].setAttribute("id", "miniTarget" + va.target.index);
						divWrapper.appendChild(targetSprites[va.target.index]);
						new Target(targetsCoords[va.target.index][0], targetsCoords[va.target.index][1], "userVerifyTarget", va.target.index, targetTracker[va.target.index]);
						updateTargets();
						
            va.onTarget = false;
						va.initialize(true, false); //refreshes all the values for the va, but doesn't restart any of the main functions. True means add the delay. But if it's fastForwarding it won't add the delay (see if statement on line 320). In hindsight, it should still add the delay, just divided by 10.
            //va.chooseTarget();
					}
					else if ((va.task == 1)  &&  ((endTime2 - va.tagAndVerifyDelayStart) >= (timeToVerify))) {
						vaVerifyTargets[va.target.index].remove();
						targetSprites[va.target.index].remove();
						targetTracker[va.target.index] = 3;
						targetsVerified += tagTracker[va.target.index];
						updateScore();
						updateTargets();
						
            va.onTarget = false;
						va.initialize(true, false);
            //va.chooseTarget();
					}
				}
				if(!va.fastForward) {
					window.setTimeout(vaTagAndVerify, 100); //10fps
        }
			}

			
			function ultraRecorder() {
				endTime = new Date();
				elapsedTime = endTime - startTime;
        var iAccel = rightAccelButton ? 0.03 : -0.03
				log += truncate(elapsedTime, 1) + ", "  + truncate(gpRecorder[0], 1) + ", " + truncate(gpRecorder[1], 1) + ", " + truncate(saveDirection[0], 1) + ", " + truncate(saveDirection[1], 1) + ", " + iAccel + ", " + lastRole + ", " + lastTargetIndex + ", " + targetsVerified + '\n';
				//the += "/n" part allows it to write on a new line each time.
//				localStorage.setItem("userLog", log); //data is saved to local storage before it is logged onto the text file.
	//			window.setTimeout(ultraRecorder, 100);
			}
			function vaUltraRecorder() {
				var endTime2 = new Date();
				elapsedTime = endTime2 - startTime;
				vaLog += truncate(elapsedTime, 1) + ", " + truncate(va.position.x, 1) + ", " + truncate(va.position.y, 1) + ", " + va.accel + ", "+ va.lastRole + ", " + va.target.index + ", " + va.behavior + '\n';
				
//				localStorage.setItem("vaLog", vaLog);
	//			window.setTimeout(vaUltraRecorder, 100);
			}
			function truncate (num, digits) {
				var numS = num.toString(),
					decPos = numS.indexOf('.'),
					substrLength = decPos == -1 ? numS.length : 1 + decPos + digits,
					trimmedResult = numS.substr(0, substrLength),
					finalResult = isNaN(trimmedResult) ? 0 : trimmedResult;
				return parseFloat(finalResult);
			}
			function logger() {
				var xhr = new XMLHttpRequest();
				xhr.open("POST", "/save");
				xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				xhr.send("record=" +  log);
			}
			function vaLogger(done) {
				var xhr = new XMLHttpRequest();
				xhr.addEventListener('readystatechange', function(event) {
					if (xhr.readyState === XMLHttpRequest.DONE) {
						if (xhr.status === 200) {
							if (done) {
								window.location.replace('survey2');
							}
						}
					}
				});
				xhr.open("POST", "/vaSave");
				xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				xhr.send("vaRecord=" +  vaLog);
			}
			function logCookie() {
					document.cookie = "gpRecorder0=" + gpRecorder[0] + ";";
					document.cookie = "gpRecorder1=" + gpRecorder[1] + ";";
					document.cookie = "gpRecorder2=" + gpRecorder[2] + ";";
					document.cookie = "gpRecorder3=" + gpRecorder[3] + ";";
					document.cookie = "gpSpriteCoords0=" + gpSpriteCoords[0] + ";";
					document.cookie = "gpSpriteCoords1=" + gpSpriteCoords[1] + ";";
					document.cookie = "canvasLeftMargin=" + canvasLeftMargin + ";";
					document.cookie = "canvasTopMargin=" + canvasTopMargin + ";";		
					document.cookie = "miniSprite1coords0=" + miniSprite1coords[0] + ";";		
					document.cookie = "miniSprite1coords1=" + miniSprite1coords[1] + ";";
					document.cookie = "miniSprite2coords0=" + miniSprite2coords[0] + ";";		
					document.cookie = "miniSprite2coords1=" + miniSprite2coords[1] + ";";
					document.cookie = "targetTracker=" + "[" + targetTracker.join(",") + "]"; //this is to store an array in a cookie. JSON parse to read it.
					document.cookie = "tagTracker=" + "[" + tagTracker.join(",") + "]"; // this is to store an array in a cookie. JSON parse to read it.
          document.cookie = "lastTargetIndex=" + lastTargetIndex + ";";
					document.cookie = "targetsVerified=" + targetsVerified + ";";
					document.cookie = "tagCount=" + tagCount + ";";
					document.cookie = "verifyCount=" + verifyCount + ";";
					document.cookie = "vaPosX=" + va.position.x + ";";
					document.cookie = "vaPosY=" + va.position.y + ";";
					document.cookie = "imageId=" + imageId + ";";
					document.cookie = "lastRole=" + lastRole + ";"; 
//					document.cookie = "vaLastRole=" + va.lastRole + ";"; 
					document.cookie = "startTime=" + startTime + ";";
					document.cookie = "elapsedTime=" + elapsedTime + ";";
//          document.cookie = "tagAndVerifyDelayStart=" + va.tagAndVerifyDelayStart + ";";
//					document.cookie = "vaOnTarget=" + va.onTarget + ";";
//					document.cookie = "vaTargetX=" + va.target.x + ";";
//					document.cookie = "vaTargetY=" + va.target.y + ";";
//					document.cookie = "vaTargetIndex=" + va.target.index + ";";
//					document.cookie = "vaTask=" + va.task + ";";
					document.cookie = "vaBehavior= " + va.behavior + ";";
          document.cookie = "vaState=" + JSON.stringify(va.saveState()); + ";"
			}
			function readCookie(key){ //reads the cookie as a string. This was also copied straight from stack overflow so I don't know how it works. But it do.
				var result;
				return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? (result[1]) : null;
			}
			
			function updateClock() {
				var minutes = 6 - Math.floor((elapsedTime / 1000)/60);
				var seconds = 60 - Math.floor((elapsedTime / 1000) % 60);
				if (seconds == 60) {
					seconds = 0;
					minutes++;
				}
				if (seconds >= 10) {
					clock.innerHTML = '' + minutes + ':' + seconds;
				}
				else {
					clock.innerHTML = '' + minutes + ':0' + seconds;
				}
				window.setTimeout(updateClock, 1000);
			}
			function updateScore() {
				scoreDiv.innerHTML = "Verified tags: " + targetsVerified;
			}
		})(window, document);
    </script>
  </body>
</html>