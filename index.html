<!doctype html>
<html>
  <head>
    <title>Objective One</title>
    <style>
		#bigWrapper {position:fixed; right: 10; bottom: 10; width:700px; height:700px; margin: 0 auto; overflow:hidden; z-index:2}
		#clockDiv {position:relative; width:50px; height:50px; margin: 0 auto; overflow:hidden; font-size: 20px; z-index:99; font-family: Arial, Helvetica, sans-serif;}
		#scoreDiv {position:relative; width:200px; height:50px; margin: 0 auto; padding-left: 127px; overflow:hidden; font-size: 1.5em; z-index:100; font-family: Arial, Helvetica, sans-serif;}
		#boatSprite1 {position:absolute; width:50px; height:35px; transition:none; transform-origin: 25px 17.5px; z-index: 95}
		#boatSprite2 {position:absolute; top:550px; left: 20px; width:50px; height:35px; transition: none; z-index: 93}
		#gowanusMap {position:relative; right: 10px; bottom: 10px; width:700px; height:700px; z-index: 4}
		#canvas {width:5100px; height:6600px; transition: none; z-index:1}
		#minimap {width:200px, height:228px; position:absolute; left:500px; top: 500px; border:1px solid #000000; z-index:79}
		#miniSprite1 {position:absolute; left:500px; top:690px; width:20px; height:20px; z-index:86}
		#miniSprite2 {position:absolute; left:500px; top:690px; width:20px; height:20px; z-index:85}
		.target {position: absolute; z-index:83}
    button {position: relative; z-index: 101; margin: 0 auto; font-size: 20px; font-family: Arial, Helvetica, sans-serif;}
	</style>
  </head>
  <body>
	<div id="bigWrapper">
		<canvas id="minimap" width="200" height="228"></canvas>
		<canvas id="canvas" width="5100" height="6600"></canvas>
		<img id="gowanusMap" src="canal3.png" alt="canalMap">
		<img id="boatSprite1" src="boatSprite1.png" alt="boatIcon">
		<img id="boatSprite2" src="boatSprite2.png" alt="boatIcon2">
		<img id="miniSprite1" src="miniSprite1.png">
		<img id="miniSprite2" src="miniSprite2.png">
	</div>
	<div id="clockDiv"></div>
	<div id="scoreDiv"></div>
    <script>
		(function(window, document) {
		
			var ELEMENT_IDS = {
				canvas: "canvas",
				minimap: "minimap",
				userSprite: "boatSprite1",
				buddySprite: "boatSprite2",
				gowanusMap: "gowanusMap",
				miniSprite1: "miniSprite1",
				miniSprite2: "miniSprite2",
				divWrapper: "bigWrapper",
				clock: "clockDiv",
				scoreDiv: "scoreDiv"
			};
			var EVENTS = {
				LOAD:      'load',
				MOUSEDOWN: 'mousedown',
				MOUSEMOVE: 'mousemove',
				MOUSEUP:   'mouseup'
			};
			var canvas = document.getElementById(ELEMENT_IDS.canvas);
			var minimap = document.getElementById(ELEMENT_IDS.minimap);
			var gowanusMap = document.getElementById(ELEMENT_IDS.gowanusMap);
			var divWrapper = document.getElementById(ELEMENT_IDS.divWrapper);
			var clock = document.getElementById(ELEMENT_IDS.clock);
			var scoreDiv = document.getElementById(ELEMENT_IDS.scoreDiv);
			var ctx = canvas.getContext("2d");
			var minimapContext = minimap.getContext("2d");
			var canvasTopMargin = -4400; //The map is scrolled by changing the top and left margins.
			var canvasLeftMargin = 0;
			var loadTime = 0; //Load time is factored into how long the va should fast forward
			gowanusMap.addEventListener(EVENTS.LOAD, function(event) {
				ctx.drawImage(this, 0, 0); 
				canvas.style.marginTop = canvasTopMargin + "px";
				minimapContext.drawImage(this, 0, 480, 4066, 5000, 0, 0, 200, 228);
        if (!readCookie("gpRecorder0")) {
          var button = document.createElement('button');
          button.addEventListener('click', function(event) {
            button.parentElement.removeChild(button);
            window.addEventListener('unload', function(event) {
              logCookie();
            });
            startTime = new Date().getTime();
            var behavior = (Math.random() < 0.5) ? 0 : 1;
            va = new VirtualAgent(20, 550, behavior);
            va.start(true);//true meaning start with the delay.
            interval = setInterval(pollGamepads, 500);
          });
          button.textContent = 'start';
          document.body.appendChild(button);
        }
			});

      if (!readCookie('deleted') && readCookie("gpRecorder0") != null) {
  			document.addEventListener("DOMContentLoaded", function(event) {//not sure why it doesn't work without this part
          targetInitializer(); //targetInitializer creates the targets.
		  		va.fastForward = true;
          /* If the va was trying to tag the same tag as the user, reset the
           * virtual agent with no delay (essentially let it respond 
           * instantaneously to the user getting to the tag first).
           */
          if (va.target.index === lastTargetIndex) {
            va.initialize(false, true);
          }
			  	var frameCount = timeSpentTaggingVerifying * 60/1000;
				  for (var t = 0; t < frameCount; ++t) {
					  va.update(); //fastforwarding
            vaTagAndVerify();
				  }
				  va.fastForward = false;

					if (targetTracker[va.target.index] == 0) va.task = 0;
					else if (targetTracker[va.target.index] == 2) va.task = 1;
          
				  vaLogger();
          
          updateTargets();
          
          va.startDelayStart = new Date().getTime();
          va.tagAndVerifyDelayStart = new Date().getTime();
				  va.update();
          vaTagAndVerify();
          handleFlash();
        });
			}
			var userSprite = document.getElementById(ELEMENT_IDS.userSprite);
			var buddySprite = document.getElementById(ELEMENT_IDS.buddySprite);
			var miniSprite1 = document.getElementById(ELEMENT_IDS.miniSprite1);
			var miniSprite2 = document.getElementById(ELEMENT_IDS.miniSprite2);
			var canalTriacontapentagon = [[0, 2318], [84, 2318], [430, 1755], [552, 1617], [656, 1533], [812, 1499], [1055, 1531], [1292, 1583], [1495, 1265], [1510, 1067], [1899, 327], [1972, 365], [1584, 1101], [1580, 1286], [1623, 1319], [1527, 1474], [1483, 1445], [1344, 1663], [1370, 1754], [1611, 1909], [1566, 1975], [1311, 1817], [1279, 1683], [906, 1583], [766, 1579], [1098, 1797], [1050, 1863], [675, 1626], [569, 1721], [809, 1878], [770, 1948], [525, 1793], [75, 2480], [144, 2626], [0, 2655]]; //this is the polygon of the canal. The tolerance might be a little too high, since I didn't go exactly around the perimeter.
			var vaCanalTriacontapentagon = [[0, 2318], [84, 2318], [430, 1755], [552, 1617], [656, 1533], [812, 1499], [1055, 1531], [1292, 1583], [1495, 1265], [1510, 1067], [1899, 327], [1972, 365], [1584, 1101], [1580, 1286], [1623, 1319], [1527, 1474], [1483, 1445], [1344, 1663], [1279, 1683], [906, 1583], [766, 1579], [675, 1626], [569, 1721], [525, 1793], [75, 2480], [144, 2626], [0, 2655]]; //this is used just for the va so it can't enter the side canals. Also, it is actually a icosikaiheptagon, not a triacontapentagon, but the former seems a little cumbersome.
			for (var i = 0; i<= 34; i++) {//The coordinates are multiplied because they were recorded for the map image that was half the size.
				canalTriacontapentagon[i][0] *= 2;
				canalTriacontapentagon[i][1] *= 2;
			}		
			for (var i = 0; i<= 26; i++) {
				vaCanalTriacontapentagon[i][0] *= 2;
				vaCanalTriacontapentagon[i][1] *= 2;
			}
			var miniSprite1coords = [500, 690];
			var miniSprite2coords = [500, 690];
			var rotate = 0;
			var log = '';
			var vaLog = '';
			
			var targetsCoords = [[227, 4694], [557, 4133], [1045, 3506], [1377, 3121], [2149, 3169], [2605, 3327], [2965, 2694], [3107, 2358], [3333, 1724], [3711, 960], [401, 4409], [708, 3924], [1158, 3256], [1828, 3079], [2786, 3014], [3206, 1962], [3471, 1451], [3600, 1214], [2428, 3215], [863, 3688]]; //absolute positions for 20 targets. See "canal3 with targets.png" in the hide folder to see what this looks like. Also, these aren't really ordered. The first 10 were in order, but the next ten were just put wherever there was space on the map. So target 19 is not necessarily at the end of the canal.
			var tagTargets = [];//One array for each type of target. One array for the minimap sprites.
			var userVerifyTargets = [];
			var vaVerifyTargets = [];
			var targetSprites = [];
			for (var i = 0; i<= 19; i++) { //this is necessary because the targets are appended to the wrapper, not the document body so they are a little offset I thnk.
				targetsCoords[i][0] -= 9;
				targetsCoords[i][1] -= 9;
			}
			var targetTracker = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; //0 means untagged, 1 means user verifies, 2 means va verifies, 3 means nonexistant
      var tagTracker    = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Keep track of how many tags are added to an image
			
			var accelerationData = [[0.129, 0.155, 0.168, 0.182, 0.195, 0.209, 0.223, 0.238, 0.252, 0.266, 0.281, 0.295, 0.324, 0.351, 0.364, 0.389, 0.893, 1], [0.513, 0.664, 0.692, 0.841, 0.899, 1], [0.493, 0.471, 0.731, 0.733, 0.734, 0.738, 0.92, 1], [0.72, 1]]; //I haven't implemented making a decreasing progress work. Also, these numbers represent the proportion through the canal at which point the user switched from acceleration to deceleration or vice-versa.
			var accelerationProportion = [0.768, 0.599, 0.644, 0.72]; //This is how much time is spent accelerating for each of the 4 representative models.
			var preferenceData = [0.088, 0.696]; //1 in the last index was made by me, it will not be randomly selected, only used when I want it to 100% verify
			var startDelayData = [500, 3599, 500, 1200, 801, 499, 890, 700, 900, 2700, 2401, 2598, 800, 800, 2701, 1000, 301, 3700, 4100, 4401, 6300, 4101, 4801, 4500, 2101, 6099, 5299, 5100, 3900, 3100, 6300, 4799, 3801, 4800, 4601, 3703, 5000, 9501, 3903, 5899, 4300, 4700];
			var tagTimeData = [26.7, 12.7, 10.4, 27.4, 7.7]; 
			var verifyTimeData = [6.2, 2.8, 3.2, 8.8, 3.9];
			
			var imageId = 1; //This is used to tell the tag and verify html which image to load, instead of using an html template system.
			var lastRole = null;
			var elapsedTime = 0;
			var timeSpentTaggingVerifying = 0;
			var lastTargetIndex = null;
			var targetsVerified = 0; //score
			var tagCount = 0;
			var verifyCount = 0;
		
			class Target {
				constructor(x, y, id, index, type) { //type is 0, 1, or 2, representing tagged, user verify, and va verify.
					var target = document.getElementById(id + index);
					target.setAttribute("width", 50);
					target.setAttribute("height", 50);
					target.setAttribute("class", "target");
					target.xPos = x - 14;
					target.yPos = y - 4412;
					target.style.left = target.xPos + "px";
					target.style.top = target.yPos + "px";
					
					var targetSprite = document.getElementById("miniTarget" + index);
					targetSprite.setAttribute("width", 15);
					targetSprite.setAttribute("height", 15);
					targetSprite.setAttribute("class", "target");
					targetSprite.style.left = (x-107)*0.048 + 501 + "px";
					targetSprite.style.top = (y-4864)*0.046 + 691 + "px";
					if (type == 0) {
						target.setAttribute("src", "target.png");
						targetSprite.setAttribute("src", "miniTarget.png");
					}
					if (type == 1) {
						target.setAttribute("src", "target2.png");
						targetSprite.setAttribute("src", "target2.png");
					}
					if (type == 2) {
						target.setAttribute("src", "target3.png");
						targetSprite.setAttribute("src", "target3.png");
					}
				}
			}

			class VirtualAgent {
				constructor(x, y, behavior) {
					this.behavior = behavior;
					this.sprite = document.getElementById(ELEMENT_IDS.buddySprite);
					this.position = {x:x, y:y};
					this.fastForward = false;
				}
				
				initialize(addDelay, fastForward) {
					this.magnitude = 0;
					this.onTarget = false;
					this.counter = 0;
					this.randomTaggingVerifyingTimeIndex = Math.floor(Math.random()*5);
					this.tagAndVerifyDelayStart = new Date().getTime();
					this.task = 0; //0 for tagging, 1 for verifying
					this.startDelayStart = new Date().getTime();
					this.startDelay = addDelay? startDelayData[Math.floor(Math.random()*42)] : 0; //after a target or when the page loads, it initializes with the start delay. If you come back to the page in the middle of its movement, it will not have a start delay.
					this.theta = 0;
					this.saveSpeed = 0;
					
					this.randomAccelIndex = Math.floor(Math.random()*47);
					if (this.randomAccelIndex >= 1  &&  this.randomAccelIndex <= 15) //This system handles the probabilities of getting each of the 4 representative acceleration patterns.
						this.randomAccelIndex = 0;
					else if (this.randomAccelIndex >= 16  &&  this.randomAccelIndex <= 25)
						this.randomAccelIndex = 1;
					else if (this.randomAccelIndex >= 26  &&  this.randomAccelIndex <= 43)
						this.randomAccelIndex = 2;
					else if (this.randomAccelIndex >= 44  &&  this.randomAccelIndex <= 47)
						this.randomAccelIndex = 3;
						
					this.chooseTarget();

          if (fastForward) {
            this.framesRequiredDelay = this.startDelay / 1000 * 60;
            this.framesElapsed = 0;
            this.framesElapsedDelay = 0;
          }
				}

        saveState() {
          var framesElapsed = (new Date().getTime() - va.vaTagAndVerifyDelayStart) * 1000 * 60;
          var framesElapsedDelay = (new Date().getTime() - va.startDelayStart) * 1000 * 60;
          var framesRequiredDelay = va.startDelay * 1000 * 60;
          return {
            magnitude: this.magnitude,
            counter: this.counter,
            randomTaggingVerifyingTimeIndex: this.randomTaggingVerifyingTimeIndex,
            task: this.task,
            startDelay: this.startDelay,
            theta: this.theta,
            saveSpeed: this.saveSpeed,
            randomAccelIndex: this.randomAccelIndex,
            target: this.target,
            startingDistanceToTarget: this.startingDistanceToTarget,
            killDistance: this.killDistance,
            angle: this.angle,
            onTarget: this.onTarget,
            lastRole: this.lastRole,
            framesElapsed: framesElapsed,
            framesElapsedDelay: framesElapsedDelay,
            framesRequiredDelay: framesRequiredDelay
          };
        }

        restoreState(state) {
          this.magnitude = state.magnitude;
          this.counter = state.counter;
          this.randomTaggingVerifyingTimeIndex = state.randomTaggingVerifyingTimeIndex;
          this.task = state.task;
          this.startDelay = state.startDelay;
          this.theta = state.theta;
          this.saveSpeed = state.saveSpeed;
          this.randomAccelIndex = state.randomAccelIndex;
          this.target = state.target;
          this.startingDistanceToTarget = state.startingDistanceToTarget;
          this.killDistance = state.killDistance;
          this.angle = state.angle;
          this.onTarget = state.onTarget;
          this.lastRole = state.lastRole;
          this.framesElapsed = state.framesElapsed;
          this.framesElapsedDelay = state.framesElapsedDelay;
        }

				start(addDelay) {
				/* Choose the first target, then wait for a random amount of time,
				 * before moving toward the target. For now, just wait 500 ms.
				 */
					this.initialize(addDelay, false); //delay is optional, depending on when the va is being started. it's a boolean.
          this.chooseTarget();
					handleFlash();
					vaTagAndVerify();
					if (addDelay) this.update();
				}
				
				chooseTarget() {
				/* Choose the current target for the virtual agent. */
					var vaTarget = null;
					var tagTarget = null;
					var verifyTarget = null;
					var thereAreNoAvailableTargets = true;
					for (var i = 0; i <= 19; i++) {
						if ((targetTracker[i] == 0) || (targetTracker[i] == 2)) thereAreNoAvailableTargets = false;
					}
					if (thereAreNoAvailableTargets) {
						vaTarget = [1000, 3500, 0]; //Just a random location to go when it's done. Otherwise it will search for targets until it breaks.
					}
					else {
						tagTarget = this.closestTag();
						verifyTarget = this.closestVerify();
						if (Math.random() < preferenceData[this.behavior]) {
							vaTarget = tagTarget;
						} else {
							vaTarget = verifyTarget;
						}
					}
					this.target = {x: vaTarget[0], y: vaTarget[1], index: vaTarget[2]};
					if (targetTracker[this.target.index] == 0) this.task = 0;
					else if (targetTracker[this.target.index] == 2) this.task = 1;
					this.startingDistanceToTarget = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
				}
				
				closestTag() {
					var tagTarget = null;
					var leastDistance = 10000;
					var nextDistance = 0;
					for (var i = 0; i <= 19; i++) {
            if (i == lastTargetIndex) continue; // don't go after a point the user is tagging.
						if (targetTracker[i] == 0) {
							nextDistance = this.distance(this.position.x, this.position.y, targetsCoords[i][0], targetsCoords[i][1]);
							if (nextDistance < leastDistance) {
								leastDistance = nextDistance;
								tagTarget = [targetsCoords[i][0], targetsCoords[i][1], i];
							}
						}
					}
					if (tagTarget === null) { //if there are no tag targets, return a verify target, even if it isn't the preference.
						return this.closestVerify();
					}
					else {
						return tagTarget;
					}
				}
								
				closestVerify() {
					var verifyTarget = null;
					var leastDistance = 10000;
					var nextDistance = 0;
					for (var i = 0; i <= 19; i++) {
						if (i == lastTargetIndex && this.fastForward) continue; //don't go after the new verifying point if you're fast forwarding
						if (targetTracker[i] == 2) {
							nextDistance = this.distance(this.position.x, this.position.y, targetsCoords[i][0], targetsCoords[i][1]);
							if (nextDistance < leastDistance) {
								leastDistance = nextDistance;
								verifyTarget = [targetsCoords[i][0], targetsCoords[i][1], i];
							}
						}
					}
					if (verifyTarget === null) {//if there are no verify targets, return a tag target, even if it wasn't the original preference.
						return this.closestTag();
					}
					else {
						return verifyTarget;
					}
				}
				
				chooseDirection() { //finds the exact angle to the target
					var angle = Math.atan2((this.target.y - (this.position.y + 4412)) * -1, this.target.x - (this.position.x + 14)); //adding 14 to the x coordinate and 4412 to the y coordinate is how you get from the recorders to the global position. Probably because the canvas starts at roughly that offset.
					return angle;
				}
				
				findPath() {
					var options = [];
					var startDistance = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
					if (startDistance < 100) { //if va is close to target, just go to the target, don't navigate through canal.
						return this.chooseDirection();
					}
					for (var tryDirection = 0; tryDirection <= 23; tryDirection++){ //This is movement algorithm. Start by looking in 24 evenly spaced directions.
						for (var steps = 0; steps < 1000; steps += 10) { //see what is the farthest distance you can go in each of those 24 directions
							if (inside([(this.position.x + steps * Math.cos(tryDirection * Math.PI / 12)), (this.position.y - steps * Math.sin(tryDirection * Math.PI / 12))], vaCanalTriacontapentagon)){ //0.26 is pi/12
								var endDistance = this.distance(this.position.x + steps*Math.cos(tryDirection * Math.PI / 12), this.position.y - steps*Math.sin(tryDirection * Math.PI / 12), this.target.x, this.target.y);
								if (endDistance < startDistance) options[tryDirection] = steps; //if it takes va closer, save it.
								else options[tryDirection] = 0;
							}
							else break;
						}
					}
					var pathAngle = (options.indexOf(Math.max(...options))) * Math.PI / 12; //save the biggest number in the array, multiply the index by pi/12 to get the angle.
					return pathAngle;
				}
				
				distance(vaX, vaY, targetX, targetY) { //just distance formula
					vaX += 14;
					vaY += 4412;
					return Math.sqrt((vaX - targetX)*(vaX - targetX) + (vaY - targetY)*(vaY - targetY));
				}
				
				update() {
					/* Decide whether or not to accelerate and decide what direction to
					   go.
					 */

					var endTime3 = new Date().getTime();
					if ((this.counter == 0) && ((endTime3 - this.startDelayStart) < (this.startDelay)) && (!this.fastForward)) { //this handles the delay.
						window.setTimeout(this.update.bind(this), (1000/60));
						vaUpdateMap({x: 0, y: 0});
			//					socket.emit('vaMove', {x: 0, y: 0}); //If it isn't constantly emitting no change, it will not update properly when the user moves.
						
						return;
					}

          if (this.fastForward && this.counter === 0 && this.framesElapsedDelay < this.framesRequiredDelay) {
            this.framesElapsedDelay += 1; 
            return;
          } else if (this.fastforward) {
            this.framesElapsedDelay = 0;
          }
					
					var currentDistanceToTarget = this.distance(this.position.x, this.position.y, this.target.x, this.target.y);
					var progress = 1 - currentDistanceToTarget / this.startingDistanceToTarget;
					
					if (progress <= accelerationData[this.randomAccelIndex][this.counter]) {
						this.accel = 0.03 * (this.counter % 2 === 0 ? 1 : -1);
						this.magnitude += this.accel; //since the data is a list of proportions at which there is switch, this code figure out if it is supposed to acc or decel
					}
					else this.counter++;
					if (this.magnitude < 0.03) {
						this.magnitude = 0;
						this.accel = 0;
					}
					if (this.magnitude > this.saveSpeed) //killDistance handles the excess speed va has at the end.
						this.killDistance = (this.magnitude * this.magnitude * (100/6)); //Speed divided by deceleration gives the number of frames it would take to decelerate. Speed/2 is average speed going from speed to 0. Frames it would take to decelerate times average speed = distance it would take to get to 0 speed. Formula simplified.
					else 						
						this.killDistance -= this.magnitude; //if va starts decelerating,  decrease the amount of distance va needs to slow down.
					
					
					var fuzz = Math.random()*0.3;
					var cosFuzz = Math.cos(this.theta + 1.57);				
									
					if ((currentDistanceToTarget>85) && (inside([this.position.x + this.magnitude * Math.cos(this.findPath()), this.position.y - this.magnitude * Math.sin(this.findPath())], vaCanalTriacontapentagon))) {
						//The number above (85) is the distance at which it should bounce back.
						this.angle = this.findPath();
						this.saveSpeed = this.magnitude;
						this.position.x += this.magnitude * Math.cos(this.angle);
						this.position.y -= this.magnitude * Math.sin(this.angle);
			//					socket.emit('vaMove', {x: this.magnitude * Math.cos(this.angle), y: this.magnitude * Math.sin(this.angle)});
						vaUpdateMap({x: this.magnitude * Math.cos(this.angle), y: this.magnitude * Math.sin(this.angle)});
						this.onTarget = false;
					}				
					else if (currentDistanceToTarget<=85 && this.killDistance > 4) {
						this.counter = accelerationData[this.randomAccelIndex].length - 1; //If va is near the target, make sure the counter is set so that it's only decelerating at this point.
						if (this.magnitude > 0.3  &&  !inside([this.position.x + this.magnitude * Math.cos(this.angle+fuzz+cosFuzz), this.position.y - this.magnitude * Math.sin(this.angle+fuzz+cosFuzz)], vaCanalTriacontapentagon)) {
							this.angle += Math.PI; //without this va would only bounce back when it is past 85 pixels away. But it can run into the side of the canal before that, in which case it should reverse direction.
						}
						if (inside([this.position.x + this.magnitude * Math.cos(this.angle+fuzz+cosFuzz), this.position.y - this.magnitude * Math.sin(this.angle+fuzz+cosFuzz)], vaCanalTriacontapentagon)) {
							if (currentDistanceToTarget>35  &&  this.killDistance <= 85) this.angle = this.chooseDirection(); //go directly to target
							this.position.x += this.magnitude * Math.cos(this.angle+fuzz+cosFuzz); 
							this.position.y -= this.magnitude * Math.sin(this.angle+fuzz+cosFuzz);
			//						socket.emit('vaMove', {x: this.magnitude * Math.cos(this.angle+fuzz+cosFuzz), y: this.magnitude * Math.sin(this.angle+fuzz+cosFuzz)});
							vaUpdateMap({x: this.magnitude * (Math.cos(this.angle + fuzz + cosFuzz)), y: this.magnitude * (Math.sin(this.angle + fuzz + cosFuzz))});
							this.onTarget = false;
							this.theta += 0.04; //the higher this value, the curvier its path. Obviously this is a terrible, robotic way of doing it, but I don't know how to make a fuzzy curved path.
						}
					}
					else if (currentDistanceToTarget < 35  &&  inside([this.position.x, this.position.y], vaCanalTriacontapentagon)) {
						this.onTarget = true;
            if (this.task === 0) {
              this.lastRole = 'tagging';              
            } else {
              this.lastRole = 'verifying';
            }
						vaUpdateMap({x: 0, y: 0});
			//					socket.emit('vaMove', {x: 0, y: 0});
					}
			//				socket.emit('vaMove', {x: 0, y:0}); //just for good measure.
          vaUpdateMap({x: 0, y: 0});
					vaUltraRecorder();
					if (!this.fastForward) {
						window.setTimeout(this.update.bind(this), (1000/60));
					}
				}
			}

			var interval = null; //All the gamepad variables are initialized here.
			var stick = [0, 0];
			var aButton = false;
			var accelButton = false;
			var gamepads = [];
			var gpIdx = -1;
      var gpRecorder = [50, 470, 0, 0] //gpRecorder is not the global coordinates or the local coordinates. It's the global coordinates with an offset x-14, y-4412. It records all the local movement.
			var gpSpriteCoords = [50, 470];
			var magnitude = 0;
      var xMagnitude = 0;
      var yMagnitude = 0;
			var direction = [0, 0];
			var saveDirection = [0,0];
			var angle = 1.57;
			if (!readCookie('deleted') && readCookie("gpRecorder0") != null) { //this if-else handles saving the game using cookie. It only follows the cookies path if the user moved, not if there are cookies in general.
				console.log("there be cookies");
				gpRecorder[0] = parseInt(readCookie("gpRecorder0"));
				gpRecorder[1] = parseInt(readCookie("gpRecorder1")); 
				gpRecorder[2] = parseInt(readCookie("gpRecorder2")); 
				gpRecorder[3] = parseInt(readCookie("gpRecorder3")); 
				gpSpriteCoords[0] = parseInt(readCookie("gpSpriteCoords0"));
				gpSpriteCoords[1] = parseInt(readCookie("gpSpriteCoords1"));
				canvasLeftMargin = parseInt(readCookie("canvasLeftMargin"));
				canvasTopMargin = parseInt(readCookie("canvasTopMargin"));
				miniSprite1coords[0] = parseInt(readCookie("miniSprite1coords0"));
				miniSprite1coords[1] = parseInt(readCookie("miniSprite1coords1"));			
				miniSprite2coords[0] = parseInt(readCookie("miniSprite2coords0"));
				miniSprite2coords[1] = parseInt(readCookie("miniSprite2coords1"));
				lastTargetIndex = parseInt(readCookie("lastTargetIndex")); //lastTargetIndex is used so va doesn't go after the point you made during fastforwarding
				imageId = parseInt(readCookie("imageId")); 
				targetTracker = JSON.parse(readCookie("targetTracker"));
        tagTracker = JSON.parse(readCookie("tagTracker"));
				lastRole = readCookie("lastRole"); //this is for the log I think.
				log = localStorage.getItem("userLog"); //Cookies can't save things that are multiple lines, so I use localStorage instead.
				targetsVerified = parseInt(readCookie("targetsVerified"));
				tagCount = parseInt(readCookie("tagCount"));
				verifyCount = parseInt(readCookie("verifyCount"));
				
        
        if (lastRole === "tagging") {
          tagTracker[lastTargetIndex] = parseInt(readCookie("numTags"));
        } else if (lastRole === "verifying") {
          targetsVerified += parseInt(readCookie("numVerifiedTags"));
        }
        
				if (isNaN(targetsVerified)) { targetsVerified = 0; }
				if (isNaN(imageId)) { imageId = 15; }
				var startTime = parseInt(readCookie("startTime")); //startTime is always the time when the entire program first start.
				var temp = new Date().getTime();
				var temp2 = parseInt(readCookie("elapsedTime"));
				timeSpentTaggingVerifying = temp - (temp2 + startTime); //User was tagging/verifying for this long.
				        
				var va = new VirtualAgent(parseInt(readCookie("vaPosX")), parseInt(readCookie("vaPosY")), readCookie("vaBehavior")); //it is drawn onto the old position.
        va.restoreState(JSON.parse(readCookie("vaState"))); // restore va state for fast-forwarding.

//				targetInitializer(); //targetInitializer creates the targets.
//				updateTargets(); //updateTargets draws the targets.

				vaLog = localStorage.getItem("vaLog");
				
				updateClock();
				updateScore();
        interval = setInterval(pollGamepads, 500);;
			}
			else { //if there are no cookies:
				var va = null;
        var startTime = 0;
        document.cookie = 'deleted=;expires=Thu, 01 Jan 1970 00:00:00 GMT';
        updateClock();
				updateScore();
        targetInitializer(); //targetInitializer creates the targets.
				updateTargets(); //updateTargets draws the targets.
			}
			
			function targetInitializer() { //I never really figured out how to use the Target class properly, so now I just use this method in conjunction with the class.
				for (var i = 0; i <= 19; i++) { //The way this is set up, each of the three target arrays are all length 20, they are just blank in the indices for which there is no target of that type. This is important for how the arrays are handled in other functions.
					if (targetTracker[i] == 0) {
						tagTargets[i] = document.createElement("IMG");
						tagTargets[i].setAttribute("id", "tagTarget" + i);
						divWrapper.appendChild(tagTargets[i]);
						targetSprites[i] = document.createElement("IMG");
						targetSprites[i].setAttribute("id", "miniTarget" + i);
						divWrapper.appendChild(targetSprites[i]); //If you attach it to the document body, it goes under the canvas, so I attached it to the div.
						new Target(targetsCoords[i][0], targetsCoords[i][1], "tagTarget", i, targetTracker[i]);
					}				
					else if (targetTracker[i] == 1) {
						userVerifyTargets[i] = document.createElement("IMG");
						userVerifyTargets[i].setAttribute("id", "userVerifyTarget" + i);
						divWrapper.appendChild(userVerifyTargets[i]);
						targetSprites[i] = document.createElement("IMG");
						targetSprites[i].setAttribute("id", "miniTarget" + i);
						divWrapper.appendChild(targetSprites[i]);
						new Target(targetsCoords[i][0], targetsCoords[i][1], "userVerifyTarget", i, targetTracker[i]);
					}				
					else if (targetTracker[i] == 2) {
						vaVerifyTargets[i] = document.createElement("IMG");
						vaVerifyTargets[i].setAttribute("id", "vaVerifyTarget" + i);
						divWrapper.appendChild(vaVerifyTargets[i]);
						targetSprites[i] = document.createElement("IMG");
						targetSprites[i].setAttribute("id", "miniTarget" + i);
						divWrapper.appendChild(targetSprites[i]);
						new Target(targetsCoords[i][0], targetsCoords[i][1], "vaVerifyTarget", i, targetTracker[i]);
					}
					else if (targetTracker[i] == 3) continue;
				}
//				updateTargets();
			}
			userSprite.style.left = gpSpriteCoords[0] + "px";
			userSprite.style.top = gpSpriteCoords[1] + "px";
			canvas.style.marginLeft = canvasLeftMargin + "px";
			canvas.style.marginTop = canvasTopMargin + "px";
			miniSprite1.style.left = miniSprite1coords[0] + "px";
			miniSprite1.style.top = miniSprite1coords[1] + "px";
			miniSprite2.style.left = miniSprite2coords[0] + "px";
			miniSprite2.style.top = miniSprite2coords[1] + "px";
			
			
			
			//All the initializing is done at this point.

			function pollGamepads() { //This searches for the gamepad at multiple indices. For some reason it isn't always at index 0.
				gamepads = navigator.getGamepads();
				for (var i = 0; i < gamepads.length; i++) {
					var gp = gamepads[i];
					if (gp) {
						console.log("Gamepad connected at index " + gp.index + ": " + gp.id + ". It has " + gp.buttons.length + " buttons and " + gp.axes.length + " axes.");
					
            if (gp.id.indexOf('STANDARD GAMEPAD Vendor: 046d') !== -1 && gp.id.indexOf("Product: c216") !== -1) {
              gpIdx = i;
              clearInterval(interval);
            }
          }
				}

				if (gpIdx !== -1) { //If the gamepad doesn't work, it probably wasn't at index 0, and this is the source of that problem.
					gameLoop();
				}
			}
		
			function gameLoop() {
				gamepads = navigator.getGamepads(); //in chrome, it needs to do this any time it wants input. The entire syntax for handling these gamepads seems to differ a lot between browsers.
				stick[0] = ((gamepads[gpIdx]).axes[0]); //This value varies from -1 to 1. 1 is all the way to the right.
				stick[1] = ((gamepads[gpIdx]).axes[1]); //This is the y-axis. 1 is all the way down.
				aButton = (gamepads[gpIdx]).buttons[0].pressed; //this is a boolean
				accelButton = (gamepads[gpIdx]).buttons[5].pressed;
				
				if (accelButton) {
          var stickMagnitude = Math.sqrt(stick[0] * stick[0] + stick[1] * stick[1]);
          if (stick[0] < 0.5 && stick[0] > -0.5) {
            xMagnitude -= 0.03;
          } else {
            var xStick = 0.03 * stick[0] / stickMagnitude;
            xMagnitude += xStick;
          }
          if (stick[1] < 0.5 && stick[1] > -0.5) {
            yMagnitude -= 0.03;
          } else {
            var yStick = 0.03 * stick[1] / stickMagnitude;
            yMagnitude += yStick;
          }
					magnitude += 0.03;
				}
				else{
					if (magnitude < 0.01) magnitude = 0;
					else magnitude -= 0.03;
          
          if (Math.abs(xMagnitude) < 0.01)
            xMagnitude = 0;
          else
            xMagnitude -= 0.03 * saveDirection[0];
          
          if (Math.abs(yMagnitude) < 0.01)
            yMagnitude = 0;
          else
            yMagnitude -= 0.03 * saveDirection[1];
				}

        
				
        console.log('xMagnitude - ' + xMagnitude);
        console.log('yMagnitude - ' + yMagnitude);
        
				if ((stick[0] < 0.5 && stick[0] > -0.5) && (stick[1] < 0.5 && stick[1] > -0.5)) { //it checks for larger values so you really have to move the stick to move it. It's super sensitive so it would look weird without this.
					direction[0] = saveDirection[0];
					direction[1] = saveDirection[1];
				}
				else {
					direction[0] = stick[0] / (Math.sqrt(stick[0] * stick[0] + stick[1] * stick[1])); //The direction array is components of the angle. This is slightly different from the stick array. If I used the stick array, I could slow down by pressing the stick forward only a little.
					direction[1] = stick[1] / (Math.sqrt(stick[0] * stick[0] + stick[1] * stick[1]));
					saveDirection[0] = direction[0]; //Save direction allows the inertial movement when you stop moving the stick.
					saveDirection[1] = direction[1];
				}
        
                    
        if (!((stick[0] < 0.5 && stick[0] > -0.5) && (stick[1] < 0.5 && stick[1] > -0.5))) {  // stick being moved
          //var stickAngle =  Math.atan2(stick[1], stick[0])*180.0/Math.PI;
          var stickAngle = Math.floor((Math.acos(stick[0] / (Math.sqrt(stick[0] * stick[0] + stick[1] * stick[1]))))/0.0349)
          if (stick[1] > 0) stickAngle *= -1;
          // is there less distance going left or right?
          //var diff = ((angle<0)? 180-angle: angle) - ((stickAngle<0)? 180-stickAngle: stickAngle);
          var diff = angle - stickAngle;
          if ((diff >= 90) || (diff >= -90 &&  diff < 0)) {
            rotateUser(0);
          }
          else if ((diff < -90) || (diff >= 0 && diff < 90)) {
            rotateUser(1);
          }
        }
				
				/*angle = Math.floor((Math.acos(direction[0] / (Math.sqrt(direction[0] * direction[0] + direction[1] * direction[1]))))/0.0349); //angle is used to angle the user boat. 0.0349 means it moves in intervals of 2 degrees.
				if (direction[1] > 0) angle *= -1;*/
        
        

				handleTargets(); 
				
				if (inside([(gpRecorder[0] + magnitude*2*direction[0]), (gpRecorder[1] + magnitude*2*direction[1])], canalTriacontapentagon)){ //the significance of doing it this way instead of just using gpRecorder0 and gpRecorder1 as arguments is this way, it can never leave the canal. It asks if it would be in the canal after taking one more step, not whether it is in the canal right now.
//				socket.emit('gpMove', {x1: gpRecorder[0], y1: gpRecorder[1]});
					gpUpdateMap({x1: gpRecorder[0], y1: gpRecorder[1]});
				}
				else { 
					magnitude = 1; //If it hits the canal edge, magnitude is reset to 1.
				}
				
				ultraRecorder();
				
				if (elapsedTime > 420000) { //data is only logged at the end of the 7 minutes.
					elapsedTime = 420000;
					logger();
					vaLogger(true);
				} else {
					window.setTimeout(gameLoop, (1000/60));
				}
			}
      
      function rotateUser(clockwise) {
        if  (clockwise) {
          angle -= 2;
          if (angle <= -90) angle += 180;
        }
        else {
          //if (angle >= 178)
          angle += 2;
          if (angle >= 90) angle -= 180;
         }
        //if (angle < 0)  angle += 360;
      }

	//		socket.on('gpUpdateMap', function(msg) { //I don't really use the msg from the server. It's sort of a vestige from the dragging form of the program. You probably don't need to emit this either, since there's only one user. 
			function gpUpdateMap(msg) {
				function gpShifter() { //This shifts the canvas based on the local coordinates of the user. It shifts direction depending on what edge or corner you're on.
				if (gpSpriteCoords[0] > 400  &&  gpSpriteCoords[1] < 300)
					gpHandleShift(magnitude*Math.abs(direction[0]), magnitude*Math.abs(direction[1]));
				else if (gpSpriteCoords[0] > 400)
					gpHandleShift(magnitude*Math.abs(direction[0]), 0);
				else if (gpSpriteCoords[1] < 300)
					gpHandleShift(0, magnitude*Math.abs(direction[1]));
				if ((gpSpriteCoords[0] < 300)  &&  (gpSpriteCoords[1] > 400))
					gpHandleShift(-magnitude*Math.abs(direction[0]), -magnitude*Math.abs(direction[1]));
				else if (gpSpriteCoords[0] < 300)
					gpHandleShift(-magnitude*Math.abs(direction[0]), 0);
				else if (gpSpriteCoords[1] > 400)
					gpHandleShift(0, -magnitude*Math.abs(direction[1]));
				}
				function gpHandleShift(x, y) {
					gpRecorder[2] += x; //gpRecorder 2 and 3 are the total x and y shift of the canvas. 
					gpRecorder[3] -= y;
					gpSpriteCoords[0] -= x;
					gpSpriteCoords[1] += y;
					gpRecorder[0] = gpSpriteCoords[0] + gpRecorder[2]; //I only just noticed this adds up to 0. This should get deleted.			
					gpRecorder[1] = gpSpriteCoords[1] + gpRecorder[3];
					canvasLeftMargin -= x;
					canvasTopMargin += y;
					canvas.style.marginLeft = canvasLeftMargin + "px";
					canvas.style.marginTop = canvasTopMargin + "px";
					userSprite.style.left = gpSpriteCoords[0] + "px";
					userSprite.style.top = gpSpriteCoords[1] + "px";
					updateTargets();
				}
				gpShifter();
				gpSpriteCoords[0] += magnitude * direction[0];
				gpSpriteCoords[1] += magnitude * direction[1];
				gpRecorder[0] = gpSpriteCoords[0] + gpRecorder[2];	//local coordinates + canvas offset = relatively global coordinates (+14, +4412 offset)		
				gpRecorder[1] = gpSpriteCoords[1] + gpRecorder[3];
				userSprite.style.left = gpSpriteCoords[0] + 'px';
				userSprite.style.top = gpSpriteCoords[1] + 'px';
				userSprite.style.transform = "rotate(" + angle*-2 +"deg)"; 
				miniSprite1coords[0] += (magnitude*direction[0]*0.047); //this changes the coordinates of the minisprite. I tried to do this intelligently by actually finding the ratio from the map to the minimap, but it didn't work so I just tried different numbers until it looked decent enough.
				miniSprite1coords[1] += (magnitude*direction[1]*0.045);
				miniSprite1.style.left = miniSprite1coords[0] + "px";
				miniSprite1.style.top = miniSprite1coords[1] + "px";
			};
			
			
			/*
			*/
			
			function updateTargets (x, y) { //draws the targets.
				for (var i = 0; i<=19; i++) {
					if (targetTracker[i] == 3) continue;
					if (targetTracker[i] == 0) {
						tagTargets[i].style.left = tagTargets[i].xPos - gpRecorder[2] + "px";
						tagTargets[i].style.top = tagTargets[i].yPos - gpRecorder[3] + "px";
					}
					else if (targetTracker[i] == 1) {
						userVerifyTargets[i].style.left = userVerifyTargets[i].xPos - gpRecorder[2] + "px";
						userVerifyTargets[i].style.top = userVerifyTargets[i].yPos - gpRecorder[3] + "px";						
					}
					else if (targetTracker[i] == 2 && vaVerifyTargets[i] !== undefined) {
						vaVerifyTargets[i].style.left = vaVerifyTargets[i].xPos - gpRecorder[2] + "px";
						vaVerifyTargets[i].style.top = vaVerifyTargets[i].yPos - gpRecorder[3] + "px";	
					}				
				}
			}

			function handleTargets() { //This handles clicking on the targets.
				for (var i = 0; i <= 19; i++) {
					if (i == va.target.index  &&  va.onTarget) continue; //You can't steal a target va already started.
					if ((targetTracker[i] == 0)  &&  (Math.abs(gpRecorder[0] - tagTargets[i].xPos) < 50)  &&  (Math.abs(gpRecorder[1] - tagTargets[i].yPos) < 50)  &&  (magnitude<1)  &&  (aButton)) { //If it's a tag target, and you're close, and moving slow, and pressing the a button, it executes.
						tagTargets[i].remove();
						targetSprites[i].remove();
						targetTracker[i] = 2; //The target at this index will load as a va verifies target when it restarts.
						lastRole = "tagging"; //used in the log
						lastTargetIndex = i; 
						imageId++;
						tagCount++; //Used in the log
						logCookie();
						//logger(); //It also logs before targets, not just at the end of the 7 minutes.
						//vaLogger();
            localStorage.setItem("userLog", log);
						window.location.replace('tag.html'); //I stopped using server requests since I stopped using html templates.
					}
				}
				for (var i = 0; i <= 19; i++) {
					if ((targetTracker[i] == 1)  &&  (Math.abs(gpRecorder[0] - userVerifyTargets[i].xPos) < 50)  &&  (Math.abs(gpRecorder[1] - userVerifyTargets[i].yPos) < 50)  &&  (magnitude<1)  &&  (aButton)) {
						userVerifyTargets[i].remove();
						targetSprites[i].remove();
						targetTracker[i] = 3;
						lastRole = "verifying";
						imageId++;
						targetsVerified++;
						verifyCount++;
						updateScore();
						logCookie();
						//logger();
						//vaLogger();
						localStorage.setItem("vaLog", vaLog);
						window.location.replace('verify.html');
					}
				}
			}
			
			
			function inside(point, polygon) { //This function checks if a point (array with x and y coordinate) is in a polygon (two-dimensional array). I copied it straight from stack overflow and have no idea how it works. 
				var boatX = point[0]+15, boatY = point[1]+4400; //The coordinates of the boat are for the top left corner I think, not the center, so they are tweaked a little from the (+14, +4412). Probably not tweaked well but still. 
				var inside = false;
				for (var i=0, j=polygon.length-1; i<polygon.length; j=i++) {
					var xi = polygon[i][0], yi = polygon[i][1];
					var xj = polygon[j][0], yj = polygon[j][1];
				
					var intersect = (((yi>boatY) != (yj>boatY)) && (boatX<(xj-xi)*(boatY-yi)/(yj-yi)+xi));
					if (intersect) 
						inside = !inside;
				}
				return inside;
			}
			
	//		socket.on("vaUpdateMap", function(msg) {
			function vaUpdateMap(msg) {
				va.sprite.style.left = va.position.x - gpRecorder[2] + "px";
				va.sprite.style.top = va.position.y - gpRecorder[3] + "px";
				miniSprite2coords[0] += (msg.x*0.047);
				miniSprite2coords[1] -= (msg.y*0.045);
				miniSprite2.style.left = miniSprite2coords[0] + "px";
				miniSprite2.style.top = miniSprite2coords[1] + "px";
				//va.sprite.style.transform = "rotate(" + va.angle*(180/3.14)*-2 +"deg)"; // I considered having have the va sprite rotate as well, but it looks bad with the current sprite
			};
			
			function handleFlash() { //This makes the va and it's minimap icon flash when its tagging to indicate that it is tagging/verifying. It loops independently of the other things.
				if (va.onTarget) {
					if (va.sprite.style.visibility == "hidden") {
						va.sprite.style.visibility = "visible";
						miniSprite2.style.visibility = "visible";
					}
					else {
						va.sprite.style.visibility = "hidden";
						miniSprite2.style.visibility = "hidden";
					}
				}
				else {
					va.sprite.style.visibility = "visible";
					miniSprite2.style.visibility = "visible";
				}
				window.setTimeout(handleFlash, 500);
			}
			
			function vaTagAndVerify() { //This handle the targets for the va
        if (va.fastForward) {
          if (va.onTarget) {
            var framesRequiredTag = tagTimeData[va.randomTaggingVerifyingTimeIndex] * 60;
            var framesRequiredVerify = verifyTimeData[va.randomTaggingVerifyingTimeIndex] * 60;
            // If enough frames elapsed, then update targets / score
            if (va.task === 0 && va.framesElapsed >= framesRequiredTag) {
              if (tagTargets[va.target.index]) {
                tagTargets[va.target.index].remove();
              }
              if (targetSprites[va.target.index]) {
                targetSprites[va.target.index].remove();
              }
              targetTracker[va.target.index] = 1;
              userVerifyTargets [va.target.index] = document.createElement('IMG');
              userVerifyTargets [va.target.index].setAttribute('id', 'userVerifyTarget' + va.target.index);
              divWrapper.appendChild(userVerifyTargets[va.target.index]);
              targetSprites[va.target.index] = document.createElement('IMG');
              targetSprites[va.target.index].setAttribute('id', 'miniTarget' + va.target.index);
              divWrapper.appendChild(targetSprites[va.target.index]);
              new Target(targetsCoords[va.target.index][0], targetsCoords[va.target.index][1], 'userVerifyTarget', va.target.index, targetTracker[va.target.index]);
              va.onTarget = false;
              va.initialize(true, true);              
              va.chooseTarget();
            } else if (va.task === 1 && va.framesElapsed >= framesRequiredVerify) {
              vaVerifyTargets[va.target.index].remove();
              targetSprites[va.target.index].remove();
              targetTracker[va.target.index] = 3;
              targetsVerified += tagTracker[va.target.index];
                    
              va.onTarget = false;
              va.initialize(true, true);
              va.chooseTarget();
            }
              va.framesElapsed += 1;
          }
          return;
        }
				if (!va.onTarget) {
					va.tagAndVerifyDelayStart = new Date().getTime(); //this time is constantly updated if you are not on the target so you get the exact start time when it is on the target
          
          va.lastRole = "navigating";
				}
				else if (va.onTarget) {
					var endTime2 = new Date().getTime();
					var timeToTag = tagTimeData[va.randomTaggingVerifyingTimeIndex]*1000; //there is only one random index for both of these because both arrays are the same size.
					var timeToVerify = verifyTimeData[va.randomTaggingVerifyingTimeIndex]*1000;
					if ((va.task == 0)  &&  ((endTime2 - va.tagAndVerifyDelayStart) >= (timeToTag))) {
						if (tagTargets[va.target.index]) { tagTargets[va.target.index].remove(); }
						if (targetSprites[va.target.index]) { targetSprites[va.target.index].remove(); }
						targetTracker[va.target.index] = 1; //this becomes a user verifies target.
						
						userVerifyTargets[va.target.index] = document.createElement("IMG");
						userVerifyTargets[va.target.index].setAttribute("id", "userVerifyTarget" + va.target.index);
						divWrapper.appendChild(userVerifyTargets[va.target.index]);
						targetSprites[va.target.index] = document.createElement("IMG");
						targetSprites[va.target.index].setAttribute("id", "miniTarget" + va.target.index);
						divWrapper.appendChild(targetSprites[va.target.index]);
						new Target(targetsCoords[va.target.index][0], targetsCoords[va.target.index][1], "userVerifyTarget", va.target.index, targetTracker[va.target.index]);
						updateTargets();
						
            va.onTarget = false;
						va.initialize(true, false); //refreshes all the values for the va, but doesn't restart any of the main functions. True means add the delay. But if it's fastforwarding it won't add the delay (see if statement on line 320). In hindsight, it should still add the delay, just divided by 10.
            va.chooseTarget();
					}
					else if ((va.task == 1)  &&  ((endTime2 - va.tagAndVerifyDelayStart) >= (timeToVerify))) {
						vaVerifyTargets[va.target.index].remove();
						targetSprites[va.target.index].remove();
						targetTracker[va.target.index] = 3;
						targetsVerified += tagTracker[va.target.index];
						updateScore();
						updateTargets();
						
            va.onTarget = false;
						va.initialize(true, false);
            va.chooseTarget();
					}
				}
				if(!va.fastForward) {
					window.setTimeout(vaTagAndVerify, 100); //10fps
        }
			}

			
			function ultraRecorder() {
				endTime = new Date();
				elapsedTime = endTime - startTime;
        var iAccel = accelButton ? 0.03 : -0.03
				log += truncate(elapsedTime, 1) + ", "  + truncate(gpRecorder[0], 1) + ", " + truncate(gpRecorder[1], 1) + ", " + iAccel + ", " + lastRole + ", " + targetsVerified + ", " + sessionStorage.getItem("num-tags") + ", " + sessionStorage.getItem("num-verified-tags") + '\n';
				//the += "/n" part allows it to write on a new line each time.
//				localStorage.setItem("userLog", log); //data is saved to local storage before it is logged onto the text file.
	//			window.setTimeout(ultraRecorder, 100);
			}
			function vaUltraRecorder() {
				var endTime2 = new Date();
				elapsedTime = endTime2 - startTime;
				vaLog += truncate(elapsedTime, 1) + ", " + truncate(va.position.x, 1) + ", " + truncate(va.position.y, 1) + ", " + va.accel + ", "+ va.lastRole + ", " + va.behavior + '\n';
				
//				localStorage.setItem("vaLog", vaLog);
	//			window.setTimeout(vaUltraRecorder, 100);
			}
			function truncate (num, digits) {
				var numS = num.toString(),
					decPos = numS.indexOf('.'),
					substrLength = decPos == -1 ? numS.length : 1 + decPos + digits,
					trimmedResult = numS.substr(0, substrLength),
					finalResult = isNaN(trimmedResult) ? 0 : trimmedResult;
				return parseFloat(finalResult);
			}
			function logger() {
				var xhr = new XMLHttpRequest();
				xhr.open("POST", "/save");
				xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				xhr.send("record=" +  log);
			}
			function vaLogger(done) {
				var xhr = new XMLHttpRequest();
				xhr.addEventListener('readystatechange', function(event) {
					if (xhr.readyState === XMLHttpRequest.DONE) {
						if (xhr.status === 200) {
							if (done) {
								window.location.replace('survey2');
							}
						}
					}
				});
				xhr.open("POST", "/vaSave");
				xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				xhr.send("vaRecord=" +  vaLog);
			}
			function logCookie() {
					document.cookie = "gpRecorder0=" + gpRecorder[0] + ";";
					document.cookie = "gpRecorder1=" + gpRecorder[1] + ";";
					document.cookie = "gpRecorder2=" + gpRecorder[2] + ";";
					document.cookie = "gpRecorder3=" + gpRecorder[3] + ";";
					document.cookie = "gpSpriteCoords0=" + gpSpriteCoords[0] + ";";
					document.cookie = "gpSpriteCoords1=" + gpSpriteCoords[1] + ";";
					document.cookie = "canvasLeftMargin=" + canvasLeftMargin + ";";
					document.cookie = "canvasTopMargin=" + canvasTopMargin + ";";		
					document.cookie = "miniSprite1coords0=" + miniSprite1coords[0] + ";";		
					document.cookie = "miniSprite1coords1=" + miniSprite1coords[1] + ";";
					document.cookie = "miniSprite2coords0=" + miniSprite2coords[0] + ";";		
					document.cookie = "miniSprite2coords1=" + miniSprite2coords[1] + ";";
					document.cookie = "targetTracker=" + "[" + targetTracker.join(",") + "]"; //this is to store an array in a cookie. JSON parse to read it.
					document.cookie = "tagTracker=" + "[" + tagTracker.join(",") + "]"; // this is to store an array in a cookie. JSON parse to read it.
          document.cookie = "lastTargetIndex=" + lastTargetIndex + ";";
					document.cookie = "targetsVerified=" + targetsVerified + ";";
					document.cookie = "tagCount=" + tagCount + ";";
					document.cookie = "verifyCount=" + verifyCount + ";";
					document.cookie = "vaPosX=" + va.position.x + ";";
					document.cookie = "vaPosY=" + va.position.y + ";";
					document.cookie = "imageId=" + imageId + ";";
					document.cookie = "lastRole=" + lastRole + ";"; 
//					document.cookie = "vaLastRole=" + va.lastRole + ";"; 
					document.cookie = "startTime=" + startTime + ";";
					document.cookie = "elapsedTime=" + elapsedTime + ";";
//					document.cookie = "vaOnTarget=" + va.onTarget + ";";
//					document.cookie = "vaTargetX=" + va.target.x + ";";
//					document.cookie = "vaTargetY=" + va.target.y + ";";
//					document.cookie = "vaTargetIndex=" + va.target.index + ";";
//					document.cookie = "vaTask=" + va.task + ";";
					document.cookie = "vaBehavior= " + va.behavior + ";";
          document.cookie = "vaState=" + JSON.stringify(va.saveState()); + ";"
			}
			function readCookie(key){ //reads the cookie as a string. This was also copied straight from stack overflow so I don't know how it works. But it do.
				var result;
				return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? (result[1]) : null;
			}
			
			function updateClock() {
				var minutes = 6 - Math.floor((elapsedTime / 1000)/60);
				var seconds = 60 - Math.floor((elapsedTime / 1000) % 60);
				if (seconds == 60) {
					seconds = 0;
					minutes++;
				}
				if (seconds >= 10) {
					clock.innerHTML = '' + minutes + ':' + seconds;
				}
				else {
					clock.innerHTML = '' + minutes + ':0' + seconds;
				}
				window.setTimeout(updateClock, 1000);
			}
			function updateScore() {
				scoreDiv.innerHTML = "Verified tags: " + targetsVerified;
			}
		})(window, document);
    </script>
  </body>
</html>